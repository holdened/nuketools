set cut_paste_input [stack 0]
version 13.2 v8
BackdropNode {
 inputs 0
 name BackdropNode6
 tile_color 0x4b4b4b01
 label "<center><img src=\"SideBySide.png\"> set your projection frame in this node"
 note_font_size 20
 selected true
 xpos -34232
 ypos 12071
 bdwidth 367
 bdheight 223
}
BackdropNode {
 inputs 0
 name BackdropNode7
 tile_color 0x7f000001
 label "<center><img src=\"Camera.png\"> Camera"
 note_font_size 40
 selected true
 xpos -34586
 ypos 12071
 bdwidth 270
 bdheight 230
}
BackdropNode {
 inputs 0
 name BackdropNode8
 tile_color 0x7f2f0001
 label "<center><img src=\"Shader.png\"> Geo"
 note_font_size 40
 selected true
 xpos -34163
 ypos 11794
 bdwidth 270
 bdheight 230
}
BackdropNode {
 inputs 0
 name BackdropNode9
 tile_color 0x657f0001
 label "<center><img src=\"Reformat.png\"> DMP"
 note_font_size 40
 selected true
 xpos -34163
 ypos 11494
 bdwidth 270
 bdheight 230
}
Dot {
 inputs 0
 name Dot52
 selected true
 xpos -33599
 ypos 11838
}
push $cut_paste_input
Dot {
 name Dot79
 selected true
 xpos -33498
 ypos 11807
}
push 0
push 0
push 0
add_layer {position position.red position.green position.blue position.alpha}
Group {
 inputs 5
 name Stick_Stuff
 note_font "Bitstream Vera Sans Bold"
 selected true
 xpos -33526
 ypos 11930
 addUserKnob {20 User}
 addUserKnob {41 in l PosPass T ShuffleInputP.in}
 addUserKnob {7 GlobalScale l "Global Scale" R 0 200}
 GlobalScale 100
 addUserKnob {26 ""}
 addUserKnob {68 Controls +INVISIBLE M {Simple Advanced "" "" ""}}
 addUserKnob {35 controls01 l "                   " M {Controls/Simple "python nuke.thisNode().knob('hide01').execute()" Controls/Advanced "python nuke.thisNode().knob('show01').execute()"}}
 addUserKnob {6 lookatcam l "Look at Cam Disable" -STARTLINE}
 addUserKnob {6 numberon l "Preview Mode" -STARTLINE}
 addUserKnob {26 resetline l "" +STARTLINE +HIDDEN}
 addUserKnob {22 resetall l "Reset All" +HIDDEN T "##Reset All\n\n#Execute Reset\nn = nuke.thisNode()\na = n.knob(\"reset01\")\nb = n.knob(\"reset02\")\nc = n.knob(\"reset03\")\nd = n.knob(\"reset04\")\ne = n.knob(\"reset05\")\nf = n.knob(\"reset06\")\ng = n.knob(\"reset07\")\nh = n.knob(\"reset08\")\na.execute()\nb.execute()\nc.execute()\nd.execute()\ne.execute()\nf.execute()\ng.execute()\nh.execute()\n\n#Reset Element01\nnuke.thisNode().node(\"placer\").knob(\"position\").setValue(\[0,0,0])\nnuke.thisNode().knob('whichel01').setValue(0)\n\n#Reset Element02\nnuke.thisNode().node(\"placer\").knob(\"position02\").setValue(\[0,0,0])\nnuke.thisNode().knob('whichel02').setValue(0)\n\n#Reset Element03\nnuke.thisNode().node(\"placer\").knob(\"position03\").setValue(\[0,0,0])\nnuke.thisNode().knob('whichel03').setValue(0)\n\n#Reset Element04\nnuke.thisNode().node(\"placer\").knob(\"position04\").setValue(\[0,0,0])\nnuke.thisNode().knob('whichel04').setValue(0)\n\n#Reset Element05\nnuke.thisNode().node(\"placer\").knob(\"position05\").setValue(\[0,0,0])\nnuke.thisNode().knob('whichel05').setValue(0)\n\n#Reset Element06\nnuke.thisNode().node(\"placer\").knob(\"position06\").setValue(\[0,0,0])\nnuke.thisNode().knob('whichel06').setValue(0)\n\n#Reset Element07\nnuke.thisNode().node(\"placer\").knob(\"position07\").setValue(\[0,0,0])\nnuke.thisNode().knob('whichel07').setValue(0)\n\n#Reset Element08\nnuke.thisNode().node(\"placer\").knob(\"position08\").setValue(\[0,0,0])\nnuke.thisNode().knob('whichel08').setValue(0)\n\n#Reset Element09\n#nuke.thisNode().node(\"placer\").knob(\"position09\").setValue(\[0,0,0])\n#nuke.thisNode().knob('translate09').setValue(0)\n\n#Reset Element10\n#nuke.thisNode().node(\"placer\").knob(\"position10\").setValue(\[0,0,0])\n\n" +STARTLINE}
 addUserKnob {22 hide01 +INVISIBLE T "nuke.thisNode().knob('resetall').setVisible(False)\nnuke.thisNode().knob('resetline').setVisible(False)\nnuke.thisNode().knob('outputLayers').setVisible(False)\nnuke.thisNode().knob('el01group').setVisible(False)\nnuke.thisNode().knob('el02group').setVisible(False)\nnuke.thisNode().knob('el03group').setVisible(False)\nnuke.thisNode().knob('el04group').setVisible(False)\nnuke.thisNode().knob('el05group').setVisible(False)\nnuke.thisNode().knob('el06group').setVisible(False)\nnuke.thisNode().knob('el07group').setVisible(False)            \nnuke.thisNode().knob('el08group').setVisible(False)" +STARTLINE}
 addUserKnob {22 show01 -STARTLINE +INVISIBLE T "nuke.thisNode().knob('resetall').setVisible(True)\nnuke.thisNode().knob('resetline').setVisible(True)\nnuke.thisNode().knob('outputLayers').setVisible(True)\nnuke.thisNode().knob('el01group').setVisible(True)\nnuke.thisNode().knob('el02group').setVisible(True)\nnuke.thisNode().knob('el03group').setVisible(True)\nnuke.thisNode().knob('el04group').setVisible(True)\nnuke.thisNode().knob('el05group').setVisible(True)\nnuke.thisNode().knob('el06group').setVisible(True)\nnuke.thisNode().knob('el07group').setVisible(True)            \nnuke.thisNode().knob('el08group').setVisible(True)"}
 addUserKnob {6 outputLayers l "Embed Layers" -STARTLINE +HIDDEN}
 outputLayers true
 addUserKnob {26 ""}
 addUserKnob {68 whichel01 l Element M {01 02 03 04 05 ""}}
 addUserKnob {3 toffset01 l timeOffset -STARTLINE}
 addUserKnob {6 solo01 l Solo -STARTLINE}
 addUserKnob {6 disable01 l Disable -STARTLINE}
 addUserKnob {41 position T placer.position}
 addUserKnob {20 el01group l Advanced +HIDDEN n 1}
 el01group 0
 addUserKnob {22 reset01 l Reset T "sstuff = nuke.thisNode()\n\n##Reset Values\nknobs_anim = \['translate01', 'rotate01', 'scale01', 'lookstrength01']\n\nfor var in knobs_anim:\n      sstuff.knob(var).clearAnimated()\n\n\n\n##Reset Values\nknobs = \['translate01', 'rotate01']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 0)\n      #sstuff.knob(var).clearAnimated()\n\n##Reset Values\nknobs = \['scale01', 'lookstrength01']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 1)\n      #sstuff.knob(var).clearAnimated()\n" +STARTLINE}
 addUserKnob {13 translate01 l translate}
 addUserKnob {13 rotate01 l rotate}
 addUserKnob {13 scale01 l scale}
 scale01 {1 1 1}
 addUserKnob {7 lookstrength01 l "look at strength"}
 lookstrength01 1
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 line01 l "" +STARTLINE}
 addUserKnob {68 whichel02 l Element M {01 02 03 04 05 "" ""}}
 addUserKnob {3 toffset02 l timeOffset -STARTLINE}
 addUserKnob {6 solo02 l Solo -STARTLINE}
 addUserKnob {6 disable02 l Disable -STARTLINE}
 addUserKnob {41 position02 l position T placer.position02}
 addUserKnob {20 el02group l Advanced +HIDDEN n 1}
 el02group 0
 addUserKnob {22 reset02 l Reset T "sstuff = nuke.thisNode()\n\n##Reset Values\nknobs_anim = \['translate02', 'rotate02', 'scale02', 'lookstrength02']\n\nfor var in knobs_anim:\n      sstuff.knob(var).clearAnimated()\n\n\n##Reset Values\nknobs = \['translate02', 'rotate02']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 0)\n      #sstuff.knob(var).clearAnimated()\n\n##Reset Values\nknobs = \['scale02', 'lookstrength02']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 1)\n      #sstuff.knob(var).clearAnimated()\n" +STARTLINE}
 addUserKnob {13 translate02 l translate}
 addUserKnob {13 rotate02 l rotate}
 addUserKnob {13 scale02 l scale}
 scale02 {1 1 1}
 addUserKnob {7 lookstrength02 l "look at strength"}
 lookstrength02 1
 addUserKnob {20 endGroup_1 n -1}
 addUserKnob {26 line02 l "" +STARTLINE}
 addUserKnob {68 whichel03 l Element M {01 02 03 04 05 ""}}
 addUserKnob {3 toffset03 l timeOffset -STARTLINE}
 addUserKnob {6 solo03 l Solo -STARTLINE}
 addUserKnob {6 disable03 l Disable -STARTLINE}
 addUserKnob {41 position03 l position T placer.position03}
 addUserKnob {20 el03group l Advanced +HIDDEN n 1}
 el03group 0
 addUserKnob {22 reset03 l Reset T "sstuff = nuke.thisNode()\n\n##Reset Values\nknobs_anim = \['translate03', 'rotate03', 'scale03', 'lookstrength03']\n\nfor var in knobs_anim:\n      sstuff.knob(var).clearAnimated()\n\n\n##Reset Values\nknobs = \['translate03', 'rotate03']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 0)\n      #sstuff.knob(var).clearAnimated()\n\n##Reset Values\nknobs = \['scale03', 'lookstrength03']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 1)\n      #sstuff.knob(var).clearAnimated()\n" +STARTLINE}
 addUserKnob {13 translate03 l translate}
 addUserKnob {13 rotate03 l rotate}
 addUserKnob {13 scale03 l scale}
 scale03 {1 1 1}
 addUserKnob {7 lookstrength03 l "look at strength"}
 lookstrength03 1
 addUserKnob {20 endGroup_2 n -1}
 addUserKnob {26 line03 l "" +STARTLINE}
 addUserKnob {68 whichel04 l Element M {01 02 03 04 05 ""}}
 addUserKnob {3 toffset04 l timeOffset -STARTLINE}
 addUserKnob {6 solo04 l Solo -STARTLINE}
 addUserKnob {6 disable04 l Disable -STARTLINE}
 addUserKnob {41 position04 l position T placer.position04}
 addUserKnob {20 el04group l Advanced +HIDDEN n 1}
 el04group 0
 addUserKnob {22 reset04 l Reset T "sstuff = nuke.thisNode()\n\n##Reset Values\nknobs_anim = \['translate04', 'rotate04', 'scale04', 'lookstrength04']\n\nfor var in knobs_anim:\n      sstuff.knob(var).clearAnimated()\n\n\n##Reset Values\nknobs = \['translate04', 'rotate04']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 0)\n      #sstuff.knob(var).clearAnimated()\n\n##Reset Values\nknobs = \['scale04', 'lookstrength04']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 1)\n      #sstuff.knob(var).clearAnimated()\n" +STARTLINE}
 addUserKnob {13 translate04 l translate}
 addUserKnob {13 rotate04 l rotate}
 addUserKnob {13 scale04 l scale}
 scale04 {1 1 1}
 addUserKnob {7 lookstrength04 l "look at strength"}
 lookstrength04 1
 addUserKnob {20 endGroup_3 n -1}
 addUserKnob {26 line04 l "" +STARTLINE}
 addUserKnob {68 whichel05 l Element M {01 02 03 04 05 ""}}
 addUserKnob {3 toffset05 l timeOffset -STARTLINE}
 addUserKnob {6 solo05 l Solo -STARTLINE}
 addUserKnob {6 disable05 l Disable -STARTLINE}
 addUserKnob {41 position05 l position T placer.position05}
 addUserKnob {20 el05group l Advanced +HIDDEN n 1}
 el05group 0
 addUserKnob {22 reset05 l Reset T "sstuff = nuke.thisNode()\n\n##Reset Values\nknobs_anim = \['translate05', 'rotate05', 'scale05', 'lookstrength05']\n\nfor var in knobs_anim:\n      sstuff.knob(var).clearAnimated()\n\n\n##Reset Values\nknobs = \['translate05', 'rotate05']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 0)\n      #sstuff.knob(var).clearAnimated()\n\n##Reset Values\nknobs = \['scale05', 'lookstrength05']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 1)\n      #sstuff.knob(var).clearAnimated()\n" +STARTLINE}
 addUserKnob {13 translate05 l translate}
 addUserKnob {13 rotate05 l rotate}
 addUserKnob {13 scale05 l scale}
 scale05 {1 1 1}
 addUserKnob {7 lookstrength05 l "look at strength"}
 lookstrength05 1
 addUserKnob {20 endGroup_4 n -1}
 addUserKnob {26 line05 l "" +STARTLINE}
 addUserKnob {68 whichel06 l Element M {01 02 03 04 05 ""}}
 addUserKnob {3 toffset06 l timeOffset -STARTLINE}
 addUserKnob {6 solo06 l Solo -STARTLINE}
 addUserKnob {6 disable06 l Disable -STARTLINE}
 addUserKnob {41 position06 l position T placer.position06}
 addUserKnob {20 el06group l Advanced +HIDDEN n 1}
 el06group 0
 addUserKnob {22 reset06 l Reset T "sstuff = nuke.thisNode()\n\n##Reset Values\nknobs_anim = \['translate06', 'rotate06', 'scale06', 'lookstrength06']\n\nfor var in knobs_anim:\n      sstuff.knob(var).clearAnimated()\n\n\n##Reset Values\nknobs = \['translate06', 'rotate06']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 0)\n      #sstuff.knob(var).clearAnimated()\n\n##Reset Values\nknobs = \['scale06', 'lookstrength06']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 1)\n      #sstuff.knob(var).clearAnimated()\n" +STARTLINE}
 addUserKnob {13 translate06 l translate}
 addUserKnob {13 rotate06 l rotate}
 addUserKnob {13 scale06 l scale}
 scale06 {1 1 1}
 addUserKnob {7 lookstrength06 l "look at strength"}
 lookstrength06 1
 addUserKnob {20 endGroup_5 n -1}
 addUserKnob {26 line06 l "" +STARTLINE}
 addUserKnob {68 whichel07 l Element M {01 02 03 04 05 ""}}
 addUserKnob {3 toffset07 l timeOffset -STARTLINE}
 addUserKnob {6 solo07 l Solo -STARTLINE}
 addUserKnob {6 disable07 l Disable -STARTLINE}
 addUserKnob {41 position07 l position T placer.position07}
 addUserKnob {20 el07group l Advanced +HIDDEN n 1}
 el07group 0
 addUserKnob {22 reset07 l Reset T "sstuff = nuke.thisNode()\n\n##Reset Values\nknobs_anim = \['translate07', 'rotate07', 'scale07', 'lookstrength07']\n\nfor var in knobs_anim:\n      sstuff.knob(var).clearAnimated()\n\n\n##Reset Values\nknobs = \['translate07', 'rotate07']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 0)\n      #sstuff.knob(var).clearAnimated()\n\n##Reset Values\nknobs = \['scale07', 'lookstrength07']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 1)\n      #sstuff.knob(var).clearAnimated()\n" +STARTLINE}
 addUserKnob {13 translate07 l translate}
 addUserKnob {13 rotate07 l rotate}
 addUserKnob {13 scale07 l scale}
 scale07 {1 1 1}
 addUserKnob {7 lookstrength07 l "look at strength"}
 lookstrength07 1
 addUserKnob {20 endGroup_6 n -1}
 addUserKnob {26 line07 l "" +STARTLINE}
 addUserKnob {68 whichel08 l Element M {01 02 03 04 05 06 07 08 ""}}
 addUserKnob {3 toffset08 l timeOffset -STARTLINE}
 addUserKnob {6 solo08 l Solo -STARTLINE}
 addUserKnob {6 disable08 l Disable -STARTLINE}
 addUserKnob {41 position08 l position T placer.position08}
 addUserKnob {20 el08group l Advanced +HIDDEN n 1}
 el08group 0
 addUserKnob {22 reset08 l Reset T "sstuff = nuke.thisNode()\n\n##Reset Values\nknobs_anim = \['translate08', 'rotate08', 'scale08', 'lookstrength08']\n\nfor var in knobs_anim:\n      sstuff.knob(var).clearAnimated()\n\n\n##Reset Values\nknobs = \['translate08', 'rotate08']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 0)\n      #sstuff.knob(var).clearAnimated()\n\n##Reset Values\nknobs = \['scale08', 'lookstrength08']\n\nfor var in knobs:\n      sstuff.knob(var).setValue( 1)\n      #sstuff.knob(var).clearAnimated()\n" +STARTLINE}
 addUserKnob {13 translate08 l translate}
 addUserKnob {13 rotate08 l rotate}
 addUserKnob {13 scale08 l scale}
 scale08 {1 1 1}
 addUserKnob {7 lookstrength08 l "look at strength"}
 lookstrength08 1
 addUserKnob {20 endGroup_7 n -1}
 addUserKnob {26 line08 l "" +STARTLINE}
 addUserKnob {20 ScanlineRender}
 addUserKnob {41 format T Constant1.format}
 addUserKnob {26 ""}
 addUserKnob {41 samples T ScanlineRender1.samples}
 addUserKnob {41 shutter T ScanlineRender1.shutter}
 addUserKnob {41 overscan T ScanlineRender1.overscan}
 addUserKnob {20 About}
 addUserKnob {26 instructions l "" +STARTLINE T "--------------------------Instructions-----------------------------\n\n-Expects a Position or Pref pass.\n\n-Connect all the branches and merge over your bg.\n\n-Prepare an element on a zero'd out card,  ensuring the element is touching the\nground plane. Will default to the internal card if none is added.\n\n-Use the position eye droppers to ctrl+alt click your elements into the correct Z position.\n\n-Use the Advanced controls to nudge the elements behind geo or rotate as needed.\n\n-For non planar cameras you will want to reduce or disable the Look at Cam strength.\n\n\n-----------------------------------------------------------------\n\nCreated by AK\n\nv2.1\n\nLast revision 27 May, 2022"}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x8e8e3800
  label FORMAT
  note_font_size 42
  xpos -997
  ypos -565
  bdwidth 243
  bdheight 184
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x8e8149ff
  label "Default Inbuilt Card"
  note_font_size 42
  xpos -7950
  ypos -2611
  bdwidth 485
  bdheight 275
 }
 Input {
  inputs 0
  name DeepHoldout
  xpos -937
  ypos 8
 }
 Dot {
  name Dot1
  xpos -903
  ypos 89
 }
 Input {
  inputs 0
  name Cam
  xpos -1190
  ypos -2654
  number 2
 }
 Dot {
  name Dot13
  xpos -1156
  ypos -2480
 }
set Nf94d7b80 [stack 0]
 Dot {
  name Dot2
  xpos -1156
  ypos -1797
 }
set Nf94dcb00 [stack 0]
push $Nf94dcb00
 Dot {
  name Dot38
  xpos -3099
  ypos -1786
 }
set Nf94e1a30 [stack 0]
push 0
 Switch {
  inputs 2
  which 1
  name Switch16
  xpos -3133
  ypos -1717
  disable {{lookatcam==1}}
 }
 Axis2 {
  inputs 0
  rot_order XYZ
  translate {{parent.placer.position08} {parent.placer.position08} {parent.placer.position08}}
  name AxisEl8
  xpos -3323
  ypos -1655
 }
 Input {
  inputs 0
  name El05
  xpos -4813
  ypos -3873
  number 8
 }
 Dot {
  name Dot12
  xpos -4779
  ypos -3803
 }
set Nf8942370 [stack 0]
 Input {
  inputs 0
  name El04
  xpos -4944
  ypos -3874
  number 7
 }
 Dot {
  name Dot53
  xpos -4910
  ypos -3801
 }
set Nf894c130 [stack 0]
 Input {
  inputs 0
  name El03
  xpos -5074
  ypos -3874
  number 6
 }
 Dot {
  name Dot52
  xpos -5040
  ypos -3799
 }
set Nf8955f10 [stack 0]
 Input {
  inputs 0
  name El02
  xpos -5207
  ypos -3872
  number 5
 }
 Dot {
  name Dot51
  xpos -5173
  ypos -3801
 }
set Nf895fe00 [stack 0]
 Input {
  inputs 0
  name El01
  xpos -5341
  ypos -3872
  number 3
 }
 Dot {
  name Dot50
  xpos -5307
  ypos -3800
 }
set Nf8969b60 [stack 0]
 Switch {
  inputs 5
  which {{parent.whichel08}}
  name ElSwitch8
  xpos -2903
  ypos -3220
 }
add_layer {El08 El08.red El08.green El08.blue El08.alpha}
 Shuffle2 {
  fromInput1 {{0} B}
  out1 El08
  fromInput2 {{0} B}
  mappings "4 rgba.red 0 0 El08.red 0 0 rgba.green 0 1 El08.green 0 1 rgba.blue 0 2 El08.blue 0 2 rgba.alpha 0 3 El08.alpha 0 3"
  name Shuffle8
  label "\[value out1]"
  xpos -2903
  ypos -2869
  disable {{parent.outputLayers==0}}
 }
 Text2 {
  font_size_toolbar 200
  font_width_toolbar 100
  font_height_toolbar 100
  message 08
  old_message {{48 56}
    }
  box {203.5 83.5 416.5 284.5}
  xjustify center
  yjustify center
  transforms {{0 2}
    }
  font_size_values {{0 200 1 200 0 200 1 200}
    }
  cursor_position 2
  font_size 200
  center {310 184}
  cursor_initialised true
  initial_cursor_position {{310 184}
    }
  group_animations {{0} imported: 0 selected: items: "root transform/"}
  animation_layers {{1 11 310 184 0 0 1 1 0 0 0 0}
    }
  name Text8
  xpos -2903
  ypos -2791
  disable {{"\$gui?(numberon?0:1):1"}}
 }
push $Nf94d7b80
 Dot {
  name Dot33
  xpos -7583
  ypos -2480
 }
push 0
 Card2 {
  inputs 0
  rows 1
  columns 1
  translate {0 0.25 0}
  control_points {3 3 3 6 

1 {-0.5 -0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0 0 0} 
1 {0 -0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {0.5 0 0} 
1 {0.5 -0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666865 0} 0 {0 0 0} 0 {1 0 0} 
1 {-0.5 0 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0 0.5 0} 
1 {0 0 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {0.5 0.5 0} 
1 {0.5 0 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0.1666666716 0} 0 {0 -0.1666666716 0} 0 {1 0.5 0} 
1 {-0.5 0.5 0} 0 {0.1666666865 0 0} 0 {0 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0 1 0} 
1 {0 0.5 0} 0 {0.1666666716 0 0} 0 {-0.1666666716 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {0.5 1 0} 
1 {0.5 0.5 0} 0 {0 0 0} 0 {-0.1666666865 0 0} 0 {0 0 0} 0 {0 -0.1666666865 0} 0 {1 1 0} }
  name Card1
  xpos -7780
  ypos -2496
 }
 Dot {
  name Dot14
  xpos -7746
  ypos -2406
 }
 TransformGeo {
  inputs 3
  name TransformGeo2
  xpos -7617
  ypos -2410
  disable true
 }
 Input {
  inputs 0
  name Card
  xpos -7326
  ypos -2644
  number 4
  addUserKnob {20 User}
  addUserKnob {6 connected +STARTLINE}
  connected {{"\[exists input\[value number]]"}}
 }
 Switch {
  inputs 2
  which 1
  name Switch15
  xpos -7326
  ypos -2410
  disable {{Card.connected}}
 }
 Dot {
  name Dot10
  xpos -7292
  ypos -2272
 }
set Nf8a031c0 [stack 0]
 Dot {
  name Dot15
  xpos -6464
  ypos -2272
 }
set Nf8a08140 [stack 0]
 Dot {
  name Dot19
  xpos -5915
  ypos -2272
 }
set Nf8a0d090 [stack 0]
 Dot {
  name Dot3
  xpos -5480
  ypos -2272
 }
set Nf8a11fe0 [stack 0]
 Dot {
  name Dot4
  xpos -4974
  ypos -2272
 }
set Nf8a170e0 [stack 0]
 Dot {
  name Dot27
  xpos -4393
  ypos -2272
 }
set Nf8a1bf70 [stack 0]
 Dot {
  name Dot35
  xpos -3707
  ypos -2272
 }
set Nf8a20ef0 [stack 0]
 Dot {
  name Dot39
  xpos -3098
  ypos -2272
 }
 Dot {
  name Dot40
  xpos -3098
  ypos -2103
 }
 ApplyMaterial {
  inputs 2
  name ApplyMaterial8
  xpos -2903
  ypos -2107
 }
 Group {
  name TimeOffsetSafe8
  xpos -2903
  ypos -2061
  addUserKnob {20 TimeOffsetSafe}
  addUserKnob {3 time_offset l "time offset(frames)" t "This is actually a framehold run by expression. This is to get around the random node connections caused by scripts with the orignal NUke TimeOffset node in. "}
  time_offset {{parent.toffset08}}
  addUserKnob {1 Scriplet_Info +DISABLED +INVISIBLE}
  Scriplet_Info central
 }
  Input {
   inputs 0
   name Input1
   xpos 505
   ypos 27
  }
  FrameHold {
   firstFrame {{frame-time_offset}}
   name FrameHold1
   xpos 505
   ypos 80
  }
  Output {
   name Output1
   xpos 505
   ypos 167
  }
 end_group
 Dot {
  name Dot41
  xpos -2869
  ypos -1631
 }
 TransformGeo {
  inputs 3
  translate {{parent.translate08} {parent.translate08} {parent.translate08}}
  rotate {{parent.rotate08} {parent.rotate08} {parent.rotate08}}
  scaling {{parent.scale08} {parent.scale08} {parent.scale08}}
  uniform_scale {{parent.GlobalScale}}
  look_strength {{parent.lookstrength08}}
  name TransformGeo4
  xpos -3133
  ypos -1635
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch19
  xpos -3133
  ypos -1465
  disable {{Stick_Stuff.disable08==1}}
 }
set Nf8a72a40 [stack 0]
push $Nf94e1a30
 Dot {
  name Dot34
  xpos -3708
  ypos -1786
 }
set Nf8e01010 [stack 0]
push 0
 Switch {
  inputs 2
  which 1
  name Switch12
  xpos -3742
  ypos -1717
  disable {{lookatcam==1}}
 }
 Axis2 {
  inputs 0
  rot_order XYZ
  translate {{parent.placer.position07} {parent.placer.position07} {parent.placer.position07}}
  name AxisEl7
  xpos -3939
  ypos -1655
 }
push $Nf8942370
push $Nf894c130
push $Nf8955f10
push $Nf895fe00
push $Nf8969b60
 Switch {
  inputs 5
  which {{parent.whichel07}}
  name ElSwitch7
  xpos -3512
  ypos -3203
 }
add_layer {El07 El07.red El07.green El07.blue El07.alpha}
 Shuffle2 {
  fromInput1 {{0} B}
  out1 El07
  fromInput2 {{0} B}
  mappings "4 rgba.red 0 0 El07.red 0 0 rgba.green 0 1 El07.green 0 1 rgba.blue 0 2 El07.blue 0 2 rgba.alpha 0 3 El07.alpha 0 3"
  name Shuffle7
  label "\[value out1]"
  xpos -3512
  ypos -2859
  disable {{parent.outputLayers==0}}
 }
 Text2 {
  font_size_toolbar 200
  font_width_toolbar 100
  font_height_toolbar 100
  message 07
  old_message {{48 55}
    }
  box {203.5 83.5 416.5 284.5}
  xjustify center
  yjustify center
  transforms {{0 2}
    }
  font_size_values {{0 200 1 200 0 200 1 200}
    }
  cursor_position 2
  font_size 200
  center {310 184}
  cursor_initialised true
  initial_cursor_position {{310 184}
    }
  group_animations {{0} imported: 0 selected: items: "root transform/"}
  animation_layers {{1 11 310 184 0 0 1 1 0 0 0 0}
    }
  name Text7
  xpos -3512
  ypos -2802
  disable {{"\$gui?(numberon?0:1):1"}}
 }
push $Nf8a20ef0
 Dot {
  name Dot36
  xpos -3707
  ypos -2103
 }
 ApplyMaterial {
  inputs 2
  name ApplyMaterial7
  xpos -3512
  ypos -2107
 }
 Group {
  name TimeOffsetSafe7
  xpos -3512
  ypos -2061
  addUserKnob {20 TimeOffsetSafe}
  addUserKnob {3 time_offset l "time offset(frames)" t "This is actually a framehold run by expression. This is to get around the random node connections caused by scripts with the orignal NUke TimeOffset node in. "}
  time_offset {{parent.toffset07}}
  addUserKnob {1 Scriplet_Info +DISABLED +INVISIBLE}
  Scriplet_Info central
 }
  Input {
   inputs 0
   name Input1
   xpos 505
   ypos 27
  }
  FrameHold {
   firstFrame {{frame-time_offset}}
   name FrameHold1
   xpos 505
   ypos 80
  }
  Output {
   name Output1
   xpos 505
   ypos 167
  }
 end_group
 Dot {
  name Dot37
  xpos -3478
  ypos -1631
 }
 TransformGeo {
  inputs 3
  translate {{parent.translate07} {parent.translate07} {parent.translate07}}
  rotate {{parent.rotate07} {parent.rotate07} {parent.rotate07}}
  scaling {{parent.scale07} {parent.scale07} {parent.scale07}}
  uniform_scale {{parent.GlobalScale}}
  look_strength {{parent.lookstrength07}}
  name TransformGeo3
  xpos -3742
  ypos -1635
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch17
  xpos -3742
  ypos -1466
  disable {{Stick_Stuff.disable07==1}}
 }
set Nf8e9c8b0 [stack 0]
push $Nf8e01010
 Dot {
  name Dot22
  xpos -4394
  ypos -1786
 }
set Nf8ea4cb0 [stack 0]
push 0
 Switch {
  inputs 2
  which 1
  name Switch11
  xpos -4428
  ypos -1712
  disable {{lookatcam==1}}
 }
 Axis2 {
  inputs 0
  rot_order XYZ
  translate {{parent.placer.position06} {parent.placer.position06} {parent.placer.position06}}
  name AxisEl6
  xpos -4610
  ypos -1650
 }
push $Nf8942370
push $Nf894c130
push $Nf8955f10
push $Nf895fe00
push $Nf8969b60
 Switch {
  inputs 5
  which {{parent.whichel06}}
  name ElSwitch6
  xpos -4198
  ypos -3204
 }
add_layer {El06 El06.red El06.green El06.blue El06.alpha}
 Shuffle2 {
  fromInput1 {{0} B}
  out1 El06
  fromInput2 {{0} B}
  mappings "4 rgba.red 0 0 El06.red 0 0 rgba.green 0 1 El06.green 0 1 rgba.blue 0 2 El06.blue 0 2 rgba.alpha 0 3 El06.alpha 0 3"
  name Shuffle6
  label "\[value out1]"
  xpos -4198
  ypos -2875
  disable {{parent.outputLayers==0}}
 }
 Text2 {
  font_size_toolbar 200
  font_width_toolbar 100
  font_height_toolbar 100
  message 06
  old_message {{48 54}
    }
  box {203.5 83.5 416.5 284.5}
  xjustify center
  yjustify center
  transforms {{0 2}
    }
  font_size_values {{0 200 1 200 0 200}
    }
  cursor_position 2
  font_size 200
  center {310 184}
  cursor_initialised true
  initial_cursor_position {{310 184}
    }
  group_animations {{0} imported: 0 selected: items: "root transform/"}
  animation_layers {{1 11 310 184 0 0 1 1 0 0 0 0}
    }
  name Text6
  xpos -4198
  ypos -2808
  disable {{"\$gui?(numberon?0:1):1"}}
 }
push $Nf8a1bf70
 Dot {
  name Dot5
  xpos -4393
  ypos -2103
 }
 ApplyMaterial {
  inputs 2
  name ApplyMaterial1
  xpos -4198
  ypos -2107
 }
 Group {
  name TimeOffsetSafe6
  xpos -4198
  ypos -2067
  addUserKnob {20 TimeOffsetSafe}
  addUserKnob {3 time_offset l "time offset(frames)" t "This is actually a framehold run by expression. This is to get around the random node connections caused by scripts with the orignal NUke TimeOffset node in. "}
  time_offset {{parent.toffset06}}
  addUserKnob {1 Scriplet_Info +DISABLED +INVISIBLE}
  Scriplet_Info central
 }
  Input {
   inputs 0
   name Input1
   xpos 505
   ypos 27
  }
  FrameHold {
   firstFrame {{frame-time_offset}}
   name FrameHold1
   xpos 505
   ypos 80
  }
  Output {
   name Output1
   xpos 505
   ypos 167
  }
 end_group
 Dot {
  name Dot23
  xpos -4164
  ypos -1626
 }
 TransformGeo {
  inputs 3
  translate {{parent.translate06} {parent.translate06} {parent.translate06}}
  rotate {{parent.rotate06} {parent.rotate06} {parent.rotate06}}
  scaling {{parent.scale06} {parent.scale06} {parent.scale06}}
  uniform_scale {{parent.GlobalScale}}
  look_strength {{parent.lookstrength06}}
  name TransformGeo10
  xpos -4428
  ypos -1630
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch6
  xpos -4428
  ypos -1458
  disable {{Stick_Stuff.disable06==1}}
 }
set Nf8f407b0 [stack 0]
push $Nf8ea4cb0
 Dot {
  name Dot6
  xpos -4900
  ypos -1786
 }
set Nf8f48b60 [stack 0]
push 0
 Switch {
  inputs 2
  which 1
  name Switch10
  xpos -4934
  ypos -1708
  disable {{lookatcam==1}}
 }
 Axis2 {
  inputs 0
  rot_order XYZ
  translate {{parent.placer.position05} {parent.placer.position05} {parent.placer.position05}}
  name AxisEl5
  xpos -5115
  ypos -1645
 }
push $Nf8942370
push $Nf894c130
push $Nf8955f10
push $Nf895fe00
push $Nf8969b60
 Switch {
  inputs 5
  which {{parent.whichel05}}
  name ElSwitch5
  xpos -4813
  ypos -3228
 }
add_layer {El05 El05.red El05.green El05.blue El05.alpha}
 Shuffle2 {
  fromInput1 {{0} B}
  out1 El05
  fromInput2 {{0} B}
  mappings "4 rgba.red 0 0 El05.red 0 0 rgba.green 0 1 El05.green 0 1 rgba.blue 0 2 El05.blue 0 2 rgba.alpha 0 3 El05.alpha 0 3"
  name Shuffle5
  label "\[value out1]"
  xpos -4813
  ypos -2875
  disable {{parent.outputLayers==0}}
 }
 Text2 {
  font_size_toolbar 200
  font_width_toolbar 100
  font_height_toolbar 100
  message 05
  old_message {{48 53}
    }
  box {203.5 83.5 416.5 284.5}
  xjustify center
  yjustify center
  transforms {{0 2}
    }
  font_size_values {{0 200 1 200 0 200}
    }
  cursor_position 2
  font_size 200
  center {310 184}
  cursor_initialised true
  initial_cursor_position {{310 184}
    }
  group_animations {{0} imported: 0 selected: items: "root transform/"}
  animation_layers {{1 11 310 184 0 0 1 1 0 0 0 0}
    }
  name Text5
  xpos -4813
  ypos -2817
  disable {{"\$gui?(numberon?0:1):1"}}
 }
push $Nf8a170e0
 Dot {
  name Dot7
  xpos -4974
  ypos -2094
 }
 ApplyMaterial {
  inputs 2
  name ApplyMaterial2
  xpos -4813
  ypos -2098
 }
 Group {
  name TimeOffsetSafe5
  xpos -4813
  ypos -2072
  addUserKnob {20 TimeOffsetSafe}
  addUserKnob {3 time_offset l "time offset(frames)" t "This is actually a framehold run by expression. This is to get around the random node connections caused by scripts with the orignal NUke TimeOffset node in. "}
  time_offset {{parent.toffset05}}
  addUserKnob {1 Scriplet_Info +DISABLED +INVISIBLE}
  Scriplet_Info central
 }
  Input {
   inputs 0
   name Input1
   xpos 505
   ypos 27
  }
  FrameHold {
   firstFrame {{frame-time_offset}}
   name FrameHold1
   xpos 505
   ypos 80
  }
  Output {
   name Output1
   xpos 505
   ypos 167
  }
 end_group
 Dot {
  name Dot11
  xpos -4779
  ypos -1621
 }
 TransformGeo {
  inputs 3
  translate {{parent.translate05} {parent.translate05} {parent.translate05}}
  rotate {{parent.rotate05} {parent.rotate05} {parent.rotate05}}
  scaling {{parent.scale05} {parent.scale05} {parent.scale05}}
  uniform_scale {{parent.GlobalScale}}
  look_strength {{parent.lookstrength05}}
  name TransformGeo9
  xpos -4934
  ypos -1625
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch5
  xpos -4934
  ypos -1465
  disable {{Stick_Stuff.disable05==1}}
 }
set Nf8681210 [stack 0]
push $Nf8f48b60
 Dot {
  name Dot8
  xpos -5405
  ypos -1786
 }
set Nf86895c0 [stack 0]
push 0
 Switch {
  inputs 2
  which 1
  name Switch9
  xpos -5439
  ypos -1707
  disable {{lookatcam==1}}
 }
 Axis2 {
  inputs 0
  rot_order XYZ
  translate {{parent.placer.position04} {parent.placer.position04} {parent.placer.position04}}
  name AxisEl4
  xpos -5636
  ypos -1629
 }
push $Nf8942370
push $Nf894c130
push $Nf8955f10
push $Nf895fe00
push $Nf8969b60
 Switch {
  inputs 5
  which {{parent.whichel04}}
  name ElSwitch4
  xpos -5282
  ypos -3226
 }
add_layer {El04 El04.red El04.green El04.blue El04.alpha}
 Shuffle2 {
  fromInput1 {{0} B}
  out1 El04
  fromInput2 {{0} B}
  mappings "4 rgba.red 0 0 El04.red 0 0 rgba.green 0 1 El04.green 0 1 rgba.blue 0 2 El04.blue 0 2 rgba.alpha 0 3 El04.alpha 0 3"
  name Shuffle4
  label "\[value out1]"
  xpos -5282
  ypos -2883
  disable {{parent.outputLayers==0}}
 }
 Text2 {
  font_size_toolbar 200
  font_width_toolbar 100
  font_height_toolbar 100
  message 04
  old_message {{48 52}
    }
  box {203.5 83.5 416.5 284.5}
  xjustify center
  yjustify center
  transforms {{0 2}
    }
  font_size_values {{0 200 1 200 0 200 1 200}
    }
  cursor_position 2
  font_size 200
  center {310 184}
  cursor_initialised true
  initial_cursor_position {{310 184}
    }
  group_animations {{0} imported: 0 selected: items: "root transform/"}
  animation_layers {{1 11 310 184 0 0 1 1 0 0 0 0}
    }
  name Text4
  xpos -5282
  ypos -2819
  disable {{"\$gui?(numberon?0:1):1"}}
 }
push $Nf8a11fe0
 Dot {
  name Dot16
  xpos -5480
  ypos -2100
 }
 ApplyMaterial {
  inputs 2
  name ApplyMaterial3
  xpos -5282
  ypos -2104
 }
 Group {
  name TimeOffsetSafe4
  xpos -5282
  ypos -2078
  addUserKnob {20 TimeOffsetSafe}
  addUserKnob {3 time_offset l "time offset(frames)" t "This is actually a framehold run by expression. This is to get around the random node connections caused by scripts with the orignal NUke TimeOffset node in. "}
  time_offset {{parent.toffset04}}
  addUserKnob {1 Scriplet_Info +DISABLED +INVISIBLE}
  Scriplet_Info central
 }
  Input {
   inputs 0
   name Input1
   xpos 505
   ypos 27
  }
  FrameHold {
   firstFrame {{frame-time_offset}}
   name FrameHold1
   xpos 505
   ypos 80
  }
  Output {
   name Output1
   xpos 505
   ypos 167
  }
 end_group
 Dot {
  name Dot17
  xpos -5248
  ypos -1605
 }
 TransformGeo {
  inputs 3
  translate {{parent.translate04} {parent.translate04} {parent.translate04}}
  rotate {{parent.rotate04} {parent.rotate04} {parent.rotate04}}
  scaling {{parent.scale04} {parent.scale04} {parent.scale04}}
  uniform_scale {{parent.GlobalScale}}
  look_strength {{parent.lookstrength04}}
  name TransformGeo8
  xpos -5439
  ypos -1609
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch4
  xpos -5439
  ypos -1473
  disable {{Stick_Stuff.disable04==1}}
 }
set Nf8724c40 [stack 0]
push $Nf86895c0
 Dot {
  name Dot18
  xpos -5906
  ypos -1786
 }
set Nf872cff0 [stack 0]
push 0
 Switch {
  inputs 2
  which 1
  name Switch8
  xpos -5940
  ypos -1701
  disable {{lookatcam==1}}
 }
 Axis2 {
  inputs 0
  rot_order XYZ
  translate {{parent.placer.position03} {parent.placer.position03} {parent.placer.position03}}
  name AxisEl3
  xpos -6117
  ypos -1627
 }
push $Nf8942370
push $Nf894c130
push $Nf8955f10
push $Nf895fe00
push $Nf8969b60
 Switch {
  inputs 5
  which {{parent.whichel03}}
  name ElSwitch3
  xpos -5785
  ypos -3231
 }
add_layer {El03 El03.red El03.green El03.blue El03.alpha}
 Shuffle2 {
  fromInput1 {{0} B}
  out1 El03
  fromInput2 {{0} B}
  mappings "4 rgba.red 0 0 El03.red 0 0 rgba.green 0 1 El03.green 0 1 rgba.blue 0 2 El03.blue 0 2 rgba.alpha 0 3 El03.alpha 0 3"
  name Shuffle3
  label "\[value out1]"
  xpos -5785
  ypos -2885
  disable {{parent.outputLayers==0}}
 }
 Text2 {
  font_size_toolbar 200
  font_width_toolbar 100
  font_height_toolbar 100
  message 03
  old_message {{48 51}
    }
  box {203.5 83.5 416.5 284.5}
  xjustify center
  yjustify center
  transforms {{0 2}
    }
  font_size_values {{0 200 1 200 0 200 1 200}
    }
  cursor_position 2
  font_size 200
  center {310 184}
  cursor_initialised true
  initial_cursor_position {{310 184}
    }
  group_animations {{0} imported: 0 selected: items: "root transform/"}
  animation_layers {{1 11 310 184 0 0 1 1 0 0 0 0}
    }
  name Text3
  xpos -5785
  ypos -2821
  disable {{"\$gui?(numberon?0:1):1"}}
 }
push $Nf8a0d090
 Dot {
  name Dot26
  xpos -5915
  ypos -2085
 }
 ApplyMaterial {
  inputs 2
  name ApplyMaterial4
  xpos -5785
  ypos -2089
 }
 Group {
  name TimeOffsetSafe3
  xpos -5785
  ypos -2063
  addUserKnob {20 TimeOffsetSafe}
  addUserKnob {3 time_offset l "time offset(frames)" t "This is actually a framehold run by expression. This is to get around the random node connections caused by scripts with the orignal NUke TimeOffset node in. "}
  time_offset {{parent.toffset03}}
  addUserKnob {1 Scriplet_Info +DISABLED +INVISIBLE}
  Scriplet_Info central
 }
  Input {
   inputs 0
   name Input1
   xpos 505
   ypos 27
  }
  FrameHold {
   firstFrame {{frame-time_offset}}
   name FrameHold1
   xpos 505
   ypos 80
  }
  Output {
   name Output1
   xpos 505
   ypos 167
  }
 end_group
 Dot {
  name Dot20
  xpos -5751
  ypos -1603
 }
 TransformGeo {
  inputs 3
  translate {{parent.translate03} {parent.translate03} {parent.translate03}}
  rotate {{parent.rotate03} {parent.rotate03} {parent.rotate03}}
  scaling {{parent.scale03} {parent.scale03} {parent.scale03}}
  uniform_scale {{parent.GlobalScale}}
  look_strength {{parent.lookstrength03}}
  name TransformGeo7
  xpos -5940
  ypos -1607
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch3
  xpos -5940
  ypos -1473
  disable {{Stick_Stuff.disable03==1}}
 }
set Nf87c8f40 [stack 0]
push $Nf872cff0
 Dot {
  name Dot21
  xpos -6411
  ypos -1786
 }
set Nf87d12f0 [stack 0]
push 0
 Switch {
  inputs 2
  which 1
  name Switch14
  xpos -6445
  ypos -1706
  disable {{lookatcam==1}}
 }
 Axis2 {
  inputs 0
  rot_order XYZ
  translate {{parent.placer.position02} {parent.placer.position02} {parent.placer.position02}}
  name AxisEl2
  xpos -6646
  ypos -1629
 }
push $Nf8942370
push $Nf894c130
push $Nf8955f10
push $Nf895fe00
push $Nf8969b60
 Switch {
  inputs 5
  which {{parent.whichel02}}
  name ElSwitch2
  xpos -6283
  ypos -3238
 }
add_layer {El02 El02.red El02.green El02.blue El02.alpha}
 Shuffle2 {
  fromInput1 {{0} B}
  out1 El02
  fromInput2 {{0} B}
  mappings "4 rgba.red 0 0 El02.red 0 0 rgba.green 0 1 El02.green 0 1 rgba.blue 0 2 El02.blue 0 2 rgba.alpha 0 3 El02.alpha 0 3"
  name Shuffle2
  label "\[value out1]"
  xpos -6283
  ypos -2887
  disable {{parent.outputLayers==0}}
 }
 Text2 {
  font_size_toolbar 200
  font_width_toolbar 100
  font_height_toolbar 100
  message 02
  old_message {{48 50}
    }
  box {203.5 83.5 416.5 284.5}
  xjustify center
  yjustify center
  transforms {{0 2}
    }
  font_size_values {{0 200 1 200 0 200 1 200}
    }
  cursor_position 2
  font_size 200
  center {310 184}
  cursor_initialised true
  initial_cursor_position {{310 184}
    }
  group_animations {{0} imported: 0 selected: items: "root transform/"}
  animation_layers {{1 11 310 184 0 0 1 1 0 0 0 0}
    }
  name Text2
  xpos -6283
  ypos -2830
  disable {{"\$gui?(numberon?0:1):1"}}
 }
push $Nf8a08140
 Dot {
  name Dot24
  xpos -6464
  ypos -2093
 }
 ApplyMaterial {
  inputs 2
  name ApplyMaterial5
  xpos -6283
  ypos -2097
 }
 Group {
  name TimeOffsetSafe2
  xpos -6283
  ypos -2071
  addUserKnob {20 TimeOffsetSafe}
  addUserKnob {3 time_offset l "time offset(frames)" t "This is actually a framehold run by expression. This is to get around the random node connections caused by scripts with the orignal NUke TimeOffset node in. "}
  time_offset {{parent.toffset02}}
  addUserKnob {1 Scriplet_Info +DISABLED +INVISIBLE}
  Scriplet_Info central
 }
  Input {
   inputs 0
   name Input1
   xpos 505
   ypos 27
  }
  FrameHold {
   firstFrame {{frame-time_offset}}
   name FrameHold1
   xpos 505
   ypos 80
  }
  Output {
   name Output1
   xpos 505
   ypos 167
  }
 end_group
 Dot {
  name Dot25
  xpos -6249
  ypos -1605
 }
 TransformGeo {
  inputs 3
  translate {{parent.translate02} {parent.translate02} {parent.translate02}}
  rotate {{parent.rotate02} {parent.rotate02} {parent.rotate02}}
  scaling {{parent.scale02} {parent.scale02} {parent.scale02}}
  uniform_scale {{parent.GlobalScale}}
  look_strength {{parent.lookstrength02}}
  name TransformGeo6
  xpos -6445
  ypos -1609
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch2
  xpos -6445
  ypos -1494
  disable {{Stick_Stuff.disable02==1}}
 }
set Ne1b80980 [stack 0]
push $Nf87d12f0
 Dot {
  name Dot60
  xpos -6921
  ypos -1786
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch7
  xpos -6955
  ypos -1700
  disable {{lookatcam==1}}
 }
 Axis2 {
  inputs 0
  rot_order XYZ
  translate {{parent.placer.position} {parent.placer.position} {parent.placer.position}}
  name AxisEl1
  xpos -7153
  ypos -1629
 }
push $Nf8942370
push $Nf894c130
push $Nf8955f10
push $Nf895fe00
push $Nf8969b60
 Switch {
  inputs 5
  which {{parent.whichel01}}
  name ElSwitch1
  xpos -6793
  ypos -3232
 }
add_layer {El01 El01.red El01.green El01.blue El01.alpha}
 Shuffle2 {
  fromInput1 {{0} B}
  out1 El01
  fromInput2 {{0} B}
  mappings "4 rgba.red 0 0 El01.red 0 0 rgba.green 0 1 El01.green 0 1 rgba.blue 0 2 El01.blue 0 2 rgba.alpha 0 3 El01.alpha 0 3"
  name Shuffle1
  label "\[value out1]"
  xpos -6793
  ypos -2895
  disable {{parent.outputLayers==0}}
 }
 Text2 {
  font_size_toolbar 100
  font_width_toolbar 100
  font_height_toolbar 100
  message 01
  old_message {{48 49}
    }
  box {203.5 83.5 416.5 284.5}
  xjustify center
  yjustify center
  transforms {{0 2}
    }
  font_size_values {{0 200 1 200 0 200 1 200}
    }
  cursor_position 2
  center {310 184}
  cursor_initialised true
  initial_cursor_position {{310 184}
    }
  group_animations {{0} imported: 0 selected: items: "root transform/"}
  animation_layers {{1 11 310 184 0 0 1 1 0 0 0 0}
    }
  name Text1
  xpos -6793
  ypos -2839
  disable {{"\$gui?(numberon?0:1):1"}}
 }
set Ne1bbc4a0 [stack 0]
push $Nf8a031c0
 Dot {
  name Dot61
  xpos -7292
  ypos -2100
 }
 ApplyMaterial {
  inputs 2
  name ApplyMaterial6
  xpos -6793
  ypos -2104
 }
 Group {
  name TimeOffsetSafe1
  xpos -6793
  ypos -2071
  addUserKnob {20 TimeOffsetSafe}
  addUserKnob {3 time_offset l "time offset(frames)" t "This is actually a framehold run by expression. This is to get around the random node connections caused by scripts with the orignal NUke TimeOffset node in. "}
  time_offset {{parent.toffset01}}
  addUserKnob {1 Scriplet_Info +DISABLED +INVISIBLE}
  Scriplet_Info central
 }
  Input {
   inputs 0
   name Input1
   xpos 505
   ypos 27
  }
  FrameHold {
   firstFrame {{frame-time_offset}}
   name FrameHold1
   xpos 505
   ypos 80
  }
  Output {
   name Output1
   xpos 505
   ypos 167
  }
 end_group
 Dot {
  name Dot62
  xpos -6759
  ypos -1605
 }
 TransformGeo {
  inputs 3
  translate {{parent.translate01} {parent.translate01} {parent.translate01}}
  rotate {{parent.rotate01} {parent.rotate01} {parent.rotate01}}
  scaling {{parent.scale01} {parent.scale01} {parent.scale01}}
  uniform_scale {{parent.GlobalScale}}
  look_strength {{parent.lookstrength01}}
  name TransformGeo1
  xpos -6955
  ypos -1609
 }
push 0
 Switch {
  inputs 2
  which 1
  name Switch1
  xpos -6955
  ypos -1474
  disable {{Stick_Stuff.disable01==1}}
 }
set Ne1c24570 [stack 0]
push $Nf8a72a40
push $Nf8e9c8b0
push $Nf8f407b0
push $Nf8681210
push $Nf8724c40
push $Nf87c8f40
push $Ne1b80980
push $Ne1c24570
 Scene {
  inputs 8
  name Scene3
  xpos -5429
  ypos -874
 }
 Dot {
  name Dot63
  xpos -5405
  ypos -341
 }
 Switch {
  inputs 9
  which {{solo01?1:solo02?2:solo03?3:solo04?4:solo05?5:solo06?6:solo07?7:solo08?8:0}}
  name Switch24
  xpos -3133
  ypos -345
 }
 Constant {
  inputs 0
  channels rgb
  name Constant1
  xpos -937
  ypos -481
 }
 Dot {
  name Dot64
  xpos -903
  ypos -341
 }
 ScanlineRender {
  inputs 3
  conservative_shader_sampling false
  overscan 100
  shutteroffset centred
  motion_vectors_type distance
  name ScanlineRender1
  xpos -1190
  ypos -345
 }
 Dot {
  name Dot65
  xpos -1156
  ypos -172
 }
set Ne1c703e0 [stack 0]
 Dot {
  name Dot66
  xpos -1349
  ypos -172
 }
 Grade {
  multiply {1 0.0123051405 0 1}
  gamma 3
  black_clamp false
  unpremult rgba.alpha
  name Grade4
  xpos -1383
  ypos -130
 }
push $Ne1c703e0
 DeepRecolor {
  inputs 2
  bbox color
  targetInputAlpha true
  name DeepRecolor1
  xpos -1383
  ypos -46
 }
push $Ne1c703e0
 Switch {
  inputs 2
  which {{parent.numberon}}
  name Switch13
  xpos -1190
  ypos -46
  disable {{"\$gui?0:1"}}
 }
 Group {
  inputs 2
  name DeepMerge_Advanced
  help "- Merges all channels from A and B in deep. - Fixes issue with DeepMerge's holdout operation which exists in Nuke 11."
  tile_color 0x60ff
  xpos -1190
  ypos 85
  addUserKnob {20 DeepMerge_Advanced}
  addUserKnob {26 ""}
  addUserKnob {4 operation M {combine holdout "" ""}}
  operation holdout
  addUserKnob {26 ""}
  addUserKnob {7 blurAmt l Blur R 0 100}
  blurAmt 1
  addUserKnob {26 ""}
  addUserKnob {4 output_data l "Output Data" M {Deep 2D ""}}
  output_data 2D
  addUserKnob {26 ""}
  addUserKnob {20 Info}
  addUserKnob {26 version_info l "" +STARTLINE T "\nCreated by Ben McEwan\nwww.benmcewan.com\n\nVersion 0.2.0\nLast Updated: September 10th, 2019\n"}
  addUserKnob {1 Scriplet_Info +DISABLED +INVISIBLE}
  Scriplet_Info central
 }
  Input {
   inputs 0
   name A
   xpos 242
   ypos -499
   number 1
  }
  DeepExpression {
   temp_name0 blur
   temp_expr0 "\[value blurAmt]/2"
   chans1 deep
   rgba.alpha "alpha * 0.999999"
   deep.back "deep.back + blur"
   name DeepExpression2
   xpos 393
   ypos -499
  }
set Ne1cac180 [stack 0]
  Dot {
   name Dot1
   label "  "
   note_font "Arial Black"
   note_font_size 16
   xpos 427
   ypos -434
  }
  Input {
   inputs 0
   name B
   xpos 551
   ypos -654
  }
  DeepExpression {
   temp_name0 blur
   temp_expr0 "\[value blurAmt]/2"
   chans1 deep
   rgba.alpha "alpha * 0.999999"
   deep.back "deep.back + blur"
   name DeepExpression1
   xpos 551
   ypos -585
  }
set Ne1cc4190 [stack 0]
  Dot {
   name Dot2
   label "  "
   note_font "Arial Black"
   note_font_size 16
   xpos 788
   ypos -581
  }
set Ne1ccef90 [stack 0]
  DeepHoldout2 {
   inputs 2
   name DeepHoldout2
   xpos 754
   ypos -438
  }
push $Ne1ccef90
  Dot {
   name Dot3
   label "  "
   note_font "Arial Black"
   note_font_size 16
   xpos 895
   ypos -532
  }
  Dot {
   name Dot4
   label "  "
   note_font "Arial Black"
   note_font_size 16
   xpos 895
   ypos -395
  }
  DeepRecolor {
   inputs 2
   channels all
   targetInputAlpha true
   name DeepRecolor2
   xpos 754
   ypos -361
  }
push $Ne1cac180
push $Ne1cc4190
  DeepMerge {
   inputs 2
   drop_hidden true
   name DeepMerge2
   xpos 551
   ypos -499
  }
  Switch {
   inputs 2
   which {{operation}}
   name Switch1
   xpos 551
   ypos -356
  }
  DeepToImage {
   name DeepToImage1
   xpos 551
   ypos -279
   disable {{!output_data}}
  }
  Output {
   name Output1
   xpos 551
   ypos -199
  }
 end_group
 Output {
  name Output1
  xpos -1190
  ypos 185
 }
 Output {
  name Output2
  xpos -1190
  ypos 285
 }
 Input {
  inputs 0
  name Pos
  xpos -996
  ypos -2655
  number 1
 }
 Shuffle {
  in position
  out rgb
  name ShuffleInputP
  label "\[value in]"
  xpos -996
  ypos -1870
 }
 NoOp {
  name placer
  xpos -996
  ypos -1832
  addUserKnob {20 User}
  addUserKnob {6 testcheck_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {26 ""}
  addUserKnob {26 element01}
  addUserKnob {18 position}
  position {0 0 0}
  addUserKnob {6 position_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable01 l disable -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 element02}
  addUserKnob {18 position02 l position}
  position02 {0 0 0}
  addUserKnob {6 position02_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 element03}
  addUserKnob {18 position03 l position}
  position03 {0 0 0}
  addUserKnob {6 position03_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable_1 l disable -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 element04}
  addUserKnob {18 position04 l position}
  position04 {0 0 0}
  addUserKnob {6 position04_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable_2 l disable -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 element05}
  addUserKnob {18 position05 l position}
  position05 {0 0 0}
  addUserKnob {6 position05_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable_3 l disable -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {26 element06}
  addUserKnob {18 position06 l position}
  position06 {0 0 0}
  addUserKnob {6 position06_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable_4 l disable -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {18 position07 l position}
  position07 {0 0 0}
  addUserKnob {6 position07_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable7 -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {18 position08 l position}
  position08 {0 0 0}
  addUserKnob {6 position08_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable8 -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {18 position09}
  position09 {0.06585811824 0.07954712957 0.08282196522}
  addUserKnob {6 position09_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable9 -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {18 position10}
  position10 {-52.18114471 51.54669952 -182.9402313}
  addUserKnob {6 position10_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 disable10 -STARTLINE}
  addUserKnob {26 ""}
  addUserKnob {6 peeps6_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 peeps5_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 peeps4_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 peeps3_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 peeps2_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
  addUserKnob {6 tsst_panelDropped l "panel dropped state" -STARTLINE +HIDDEN}
 }
push $Ne1bbc4a0
push 0
push 0
 Viewer {
  inputs 3
  frame_range 1001-1035
  input_number 2
  colour_sample_bbox {1.048828125 0.3427734375 1.049804688 0.34375}
  viewerProcess "Show_LUT_CDL (rec709)"
  name Viewer1
  xpos -6683
  ypos -2839
 }
end_group
StickyNote {
 inputs 0
 name StickitNode01
 tile_color 0xff
 gl_color 0xff
 label "\n<div align=\"left\">\n<font color=\"red\"><b>Important</b></font>\n\nThank you for testing out stickit alpha build 1.0\n\nThis Toolset is very limited and a more along the lines of a proof of concept.\nIt have been used in production but in a very tight scope.\nThis tool is <b>NOT recommended for use in production</b> yet due to the issues described below:\n\n<font color=\"red\"><b>Known Bugs in this version, fixed soon(read before use!)</b></font>\n-First frame is not being calculated, so always give the track a one frame handle.\n-The points from the first tracked frame will be used to drive the warp. \nThis means that you should preferably use a reference frame in the beginning of the framerange.\n-I have not yet implemented the feature to manually help animate points into place if they have \ndrifted away from their original position.  This means that during longer sequences if the points drift \noff target it will not be possible to get them back on track. (so avoid long sequences)\n-MotionBlur is being applied towards previous frame and not as a center frame.\n-The output STmap will have a 1px offset compared to the innode result.\n-The Solve is single-threaded so it will be slow and the UI will hang and not update during the solve process.\n\nKnown Bugs in TheFoundrys Hands:\n-\[Windows Only] There is a bug in the window version of Nuke that will make nuke hang for a long time \nwhen trying to copy a spline warp with too much data inside, from one nuke window to another \n(the nuke terminal window will show a ton of spam messages).\n-There is a bug in Nuke that sometimes causes nuke to delete all points in the splinewarp node if you copy/paste it.\n</div>\n \n \n \n \n\n\n\n"
 selected true
 xpos -33520
 ypos 12024
}
push $cut_paste_input
Group {
 name StickIt4
 tile_color 0x2f66ff
 selected true
 xpos -33635
 ypos 12245
 addUserKnob {20 Main l "Main - StickIt"}
 addUserKnob {26 Headline l "" +STARTLINE T "<font color=#9090EE size=\"7\">S</font><font color=#8080DD size=\"7\">T</font><font color=#7070CC size=\"7\">i</font><font color=#6060BB size=\"7\">C</font><font color=#5050AA size=\"7\">K</font><font color=#6060BB size=\"7\">i</font><font color=#7070CC size=\"7\">T</font><font color=#8080DD size=\"3\">v</font><font color=#9090EE size=\"2\">1.0</font>"}
 addUserKnob {26 HeadlineB l "" +STARTLINE T "<font color=#9090EE size=\"2\">by Mads Hagbarth Lund</font>"}
 addUserKnob {26 range_devider l "<b><font color=\"lightgreen\">Input</font><b>"}
 addUserKnob {3 RefrenceFrameInput l "Reference Frame"}
 RefrenceFrameInput 2
 addUserKnob {3 InputFrom l "Range From"}
 InputFrom 1
 addUserKnob {3 InputTo l To -STARTLINE}
 InputTo 100
 addUserKnob {22 Button_SetToGlobal l "Set To Global" -STARTLINE T "nuke.thisNode().knob(\"InputFrom\").setValue(float(nuke.knob(\"first_frame\")))\nnuke.thisNode().knob(\"InputTo\").setValue(float(nuke.knob(\"last_frame\")))"}
 addUserKnob {26 Devider_Options l "<b><font color=#70EE70>Options</font><b>"}
 addUserKnob {4 SolveMethod l "Solve Method" M {Triangulation Nearest}}
 addUserKnob {4 ApplyMethod l "Apply Method" M {"Match Move" Stabilize ""}}
 addUserKnob {4 FilterMethod l "Filter Method" M {Impulse "Cubic " Keys Simon Rifman Mitchell Parzen Notch Lanczos4 Lanczos6 Sinc4}}
 addUserKnob {6 enableMotionBlur l "Enable Motion Blur" +STARTLINE}
 addUserKnob {26 DeviderView l "<b><font color=#70EE70>Display</font><b>"}
 addUserKnob {6 HideSource l "Hide Source" +STARTLINE}
 addUserKnob {41 previewFeatures l "Preview Features" T si_ct.previewFeatures}
 addUserKnob {41 displayTracks l "Show Features" T si_ct.displayTracks}
 addUserKnob {6 DisableWarp l "Disable Warp" +STARTLINE}
 addUserKnob {26 devider_solve l "<b><font color=#70EE70>Analyse</font><b>"}
 addUserKnob {22 RunAnalyse l Analyse T "nuke.toNode(\"si_ct\").knob(\"clearTrack\").execute()\n\nnuke.toNode(\"si_ct\").knob(\"trackFeatures\").execute()\n\n\n\n" +STARTLINE}
 addUserKnob {26 next l "" -STARTLINE T "-> "}
 addUserKnob {22 STiCKiT l Solve -STARTLINE T "taskB = nuke.ProgressTask('Calculating Solve, please wait...') \n\n\nimport string #This is used by the code. Include!\nimport math\nimport struct\n'''\n#Todo:\n-Get all points from the CameraTracker and put them into a list\n-Create a initial set of points, this could be all points on a certain frame or a general set of points.\n  If we take from a certain frame we need to get a list of all points that are on the specified frame\n-For every source object we put in a single value that is the XY pos of the object in the specified frame\n\n-For every target object we triangulate the nearby points and get a new position, we do that for all the frames in the framerange specified.\n-For every target object we bake animation calculated in the step above\n\n\nRemember that we must save the new calculated position into a new list or modify the exsisting to get perfect results\n'''\n'''================================================================================\n; Function:          CreateWarpPinPair(myNode):\n; Description:       Create a Splinewarp pin pair.\n; Parameter(s):      node - The node create pin in\n; Return(s):         Returns a pair of pin objects (_curveknob.Stroke objects) \[source,target]\n;                    specified - Only take knobs with this tag (like \"UserTrack\" from a cameratracker)\n; Note(s):            N/A\n;=================================================================================='''\ndef CreateWarpPinPair(myNode,pointlist,refframe):\n  lutsKnob = myNode.knob(\"curves\")\n  #print \"--CreateWarpPair--\"\n  #print pointlist\n  #ItemX = \[1,2,3,4,5,6]\n  ItemX = pointlist\n\n  #Ok, this is messy but is added for Nuke 6, 7 support.\n  #We cunstruct the pins with a basic FromScript method.\n  Header = \"\"\"AddMode 0 0 1 0 \{\{v x3f99999a\}\n    \{f 0\}\n    \{n\n     \{layer OverTheSticky\n      \{f 0\}\n      \{t x44800000 x44428000\}\n      \{a\}\n  \"\"\"\n  Content = \"\"\"            \{cubiccurve Pin1 262656 bezier\n     \{cc\n      \{f 8224\}\n      \{px 1\n       \{0 0\}\n       \{x43d20000 x43e60000\}\n       \{0 0\}\}\}\n     \{tx 1 x43d20000 x43e60000\}\n     \{a ro 0 go 0 bo 0 ao 0 mbo 0 mb 1 mbs x3f000000 mbsot 0 mbso 0 fo 1 fx 0 fy 0 ff 1 ft 0 str 1 pt 0 ab 1\}\}\n  \"\"\"\n  Footer = \"\"\"  \{edge Pin2222 Pin1111\n   \{cp 0 0 0 0 0\n    \{\{\{\{1 x3f000000\}\}\n     \{\{1 x3f000000\}\}\}\n     \{\{\{1 x3f000000\}\}\n     \{\{1 x3f000000\}\}\}\n     \{\{\{1 x3f000000\}\}\n     \{\{1 x3f000000\}\}\}\n     \{\{\{1 x3f000000\}\}\n     \{\{1 x3f000000\}\}\}\}\}\n   \{a\}\}\n  \"\"\"\n  MessageC = \"\"\n  MessageF = \"\"\n  Message = Header\n\n\n  for i in range(0, len(ItemX)):\n\n\n      convertedX = float_to_hex(float(pointlist\[i]\[int(refframe-float(pointlist\[i]\[0]\[0]))]\[1]))\n      ConvertedY = float_to_hex(float(pointlist\[i]\[int(refframe-float(pointlist\[i]\[0]\[0]))]\[2]))\n\n\n      Pre_Message = Content.replace(\"Pin1\", \"Pin\"+str(i*2+1))\n      Pre_Message = Pre_Message.replace(\"x43d20000 x43e60000\", \"x\"+convertedX+\" x\"+ConvertedY)\n\n      #Pre_Message = Pre_Message.replace(\"parent.CameraTracker1.UserTrack0\", \"parent.\"+SelectedNode.name() + \".UserTrack\" + str(i)+\"(\"+ItemFrameStart\[i]\[:-2]+\")\")\n      MessageC = Pre_Message + MessageC\n\n      Pre_Message = Content.replace(\"Pin1\", \"Pin\"+str(i*2+2))\n      Pre_Message = Pre_Message.replace(\"x43d20000 x43e60000\",  \"x\"+convertedX+\" x\"+ConvertedY)\n      #Pre_Message = Pre_Message.replace(\"parent.CameraTracker1.UserTrack0\", \"parent.\"+SelectedNode.name() + \".UserTrack\" + str(i))\n      MessageC = Pre_Message + MessageC\n  MessageC, result = MessageC\[:-1], MessageC\[-1]\n  Message = Message + MessageC\n  Message = Message + \"\"\"\}\}\n  \"\"\"\n  for i in range(0, len(ItemX)):\n      Pre_Message = Footer.replace(\"Pin1111\", \"Pin\"+str(i*2+1))\n      Pre_Message = Pre_Message.replace(\"Pin2222\", \"Pin\"+str(i*2+2))\n      MessageF = Pre_Message + MessageF\n\n  MessageF, result = MessageF\[:-1], MessageF\[-1]\n  Message = Message + MessageF\n  Message = Message + \"\"\"\}\n  \"\"\"\n\n\n  #print Message\n  lutsKnob.fromScript(Message)\n\n  #print pointlist\[0]\n  for i in range(0, len(ItemX)):\n    PinTarget = lutsKnob.toElement(\"Pin\"+str(i*2+1))\n    PinSource = lutsKnob.toElement(\"Pin\"+str(i*2+2))\n    PinSource.getTransform().getTranslationAnimCurve(0).removeAllKeys()\n    PinSource.getTransform().getTranslationAnimCurve(1).removeAllKeys()\n    PinTarget.getTransform().getTranslationAnimCurve(0).removeAllKeys()\n    PinTarget.getTransform().getTranslationAnimCurve(1).removeAllKeys()\n    PinSource.getTransform().addTranslationKey(refframe,0,0,100.0)\n    for ix in range(0, len(pointlist\[i])):\n\n      PinTarget.getTransform().getTranslationAnimCurve(0).addKey(pointlist\[i]\[ix]\[0],float(pointlist\[i]\[ix]\[1])-float(pointlist\[i]\[int(refframe-float(pointlist\[i]\[0]\[0]))]\[1]))\n      PinTarget.getTransform().getTranslationAnimCurve(1).addKey(pointlist\[i]\[ix]\[0],float(pointlist\[i]\[ix]\[2])-float(pointlist\[i]\[int(refframe-float(pointlist\[i]\[0]\[0]))]\[2]))\n      #print pointlist\[i]\[ix]\[0]\n      #print float(pointlist\[i]\[ix]\[0]),float(pointlist\[i]\[ix]\[1]),float(pointlist\[i]\[ix]\[2]),1.0\n    #print \"end\"\n\n\n\n'''================================================================================\n; Function:             float_to_hex(float):\n; Description:          Converts a float to a hex decimal\n;=================================================================================='''\ndef float_to_hex(f):\n    return hex(struct.unpack('<I', struct.pack('<f', f))\[0])\n\n'''================================================================================\n; Function:             ExportCameraTrack(myNode):\n; Description:          Extracts all 2D Tracking Featrures from a 3D CameraTracker node (not usertracks).\n; Parameter(s):         myNode - A CameraTracker node containing tracking features\n; Return:               Output - A list of points formated \[ \[\[Frame,X,Y]\[...]] \[\[...]\[...]] ]\n;                           \n; Note(s):              N/A\n;=================================================================================='''\ndef ExportCameraTrack(myNode):\n    myKnob = myNode.knob(\"serializeKnob\")\n    myLines = myKnob.toScript()    \n    DataItems = string.split(myLines, '\\n')\n    Output = \[]\n    for index,line in enumerate(DataItems):\n        tempSplit = string.split(line, ' ')\n        if (len(tempSplit) > 4 and tempSplit\[ len(tempSplit)-1] == \"10\") or (len(tempSplit) > 6 and  tempSplit\[len(tempSplit)-1] == \"10\"): #Header\n            #The first object always have 2 unknown ints, lets just fix it the easy way by offsetting by 2\n            if len(tempSplit) > 6 and  tempSplit\[6] == \"10\":\n                offsetKey = 2\n                offsetItem = 0\n            else:\n                offsetKey = 0\n                offsetItem = 0\n            #For some wierd reason the header is located at the first index after the first item. So we go one step down and look for the header data.\n            itemHeader = string.split(myLines, '\\n')\[index+1]\n            itemHeadersplit = string.split(itemHeader, ' ')\n            itemHeader_UniqueID = itemHeadersplit\[1]\n\n            #So this one is rather wierd but after a certain ammount of items the structure will change again.\n            firstOffset = 0\n            secondOffset = 0\n            secondItem = string.split(myLines, '\\n')\[index+2]\n            secondSplit = string.split(secondItem, ' ')\n            if len(secondSplit) == 7:\n                 firstOffset = 0\n\n            if len(itemHeadersplit) == 3:\n                itemHeader = string.split(myLines, '\\n')\[index+2]\n                itemHeadersplit = string.split(itemHeader, ' ')\n                offsetKey = 2\n                offsetItem = 2\n                #print \"LOOOOL\" + str(\[int(LastFrame)+(0),string.split(DataItems\[index+0], ' ')\[2]  ,string.split(DataItems\[index+0], ' ')\[3]])\n                #print secondSplit\n                #print len(secondSplit)\n                if len(secondSplit) == 11:\n                  firstOffset = 1 #In this case the 2nd item will be +1                \n                elif len(secondSplit) == 7:\n                  firstOffset = 1\n                else:\n                  firstOffset = 0 #In this case the 2nd item will be +0\n\n\n            itemHeader_FirstItem = itemHeadersplit\[3+offsetItem]\n            itemHeader_NumberOfKeys = itemHeadersplit\[4+offsetKey]\n            #Here we extract the individual XY coordinates\n            PositionList =\[]\n            PositionList.append(\[int(LastFrame)+(0),string.split(DataItems\[index+0], ' ')\[2]  ,string.split(DataItems\[index+0], ' ')\[3]])\n            for x in range(2,int(itemHeader_NumberOfKeys)):\n                if len(string.split(DataItems\[index+x+firstOffset-1], ' '))>7 and len(string.split(DataItems\[index+x+firstOffset-1], ' '))<10 and int(string.split(DataItems\[index+x+firstOffset-1], ' ')\[5]) > 0:\n                  #print \"SHIT!!! VIRUZ!!!\"\n                  #print string.split(DataItems\[index+x+firstOffset-1], ' ')\n                  #print string.split(DataItems\[index+1+firstOffset], ' ')\n                  Offset = int(string.split(DataItems\[index+x+firstOffset-1], ' ')\[7])\n                  #print Offset\n                  #print DataItems\[Offset+1]\n                  PositionList.append(\[int(LastFrame)+(x-1),string.split(DataItems\[Offset+1], ' ')\[2]  ,string.split(DataItems\[Offset+1], ' ')\[3]]) \n                  #print PositionList\n                  secondOffset = 1\n                else:\n                  PositionList.append(\[int(LastFrame)+(x-1),string.split(DataItems\[index+x+firstOffset-secondOffset], ' ')\[2]  ,string.split(DataItems\[index+x+firstOffset-secondOffset], ' ')\[3]])         \n                  #print str(LastFrame) , str(x), str(index), \"This was data\"         \n            Output.append(PositionList)\n            #print PositionList\n        elif (len(tempSplit) > 8 and tempSplit\[1] == \"0\" and tempSplit\[2] == \"1\"):\n            LastFrame = tempSplit\[3]\n        else:  #Content\n            pass\n    return Output\n\n'''================================================================================\n; Function:             GetAnimtionList(myList,myFrame):\n; Description:          Returns a list of points that contain animation between myFrame and the following frame\n; Parameter(s):         myList - A list of points formated \[ \[\[Frame,X,Y]\[...]] \[\[...]\[...]] ]\n                        myFrame - The frame to take into consideration \n; Return:               Output - A list of points formated \[ \[\[Frame,X,Y]\[...]] \[\[...]\[...]] ]\n;                           \n; Note(s):              N/A\n;=================================================================================='''\ndef GetAnimtionList(myList,nestedPoints,myFrame):   \n\n    thisFrame = int(myFrame)\n    nextFrame = int(myFrame) + 1\n    Output = \[]\n    #print item_dict\[thisFrame]\n    #print dwqdwq\n    for i,item in enumerate(item_dict\[thisFrame]):\n        if item_dict\[thisFrame]\[i]\[4]>thisFrame: \n            #Output.append(\[item_dict\[thisFrame]\[i-1],item_dict\[thisFrame]\[i]])\n            #print item_dict\[thisFrame]\[i-1]\n            #print item_dict\[thisFrame]\[i]\n            #print \[(thisFrame-item_dict\[thisFrame]\[i]\[3])]\n            outThisframe = myList\[item_dict\[thisFrame]\[i]\[2]]\[(thisFrame-item_dict\[thisFrame]\[i]\[3])]\n            #print myList\[item_dict\[thisFrame]\[i]\[2]]\[(thisFrame-item_dict\[thisFrame]\[i]\[3])+1]\n            #print myList\[item_dict\[thisFrame]\[i]\[2]]\n            #print \[(thisFrame-item_dict\[thisFrame]\[i]\[3])+1]\n            outNextframe =  myList\[item_dict\[thisFrame]\[i]\[2]]\[(thisFrame-item_dict\[thisFrame]\[i]\[3])+1]\n\n            Output.append(\[outThisframe,outNextframe])\n    return Output\n\n\n\ndef GetNearestPoints(refpoint,pointList):\n  #Distance Calculation\n  x1 = float(refpoint\[1])\n  y1 = float(refpoint\[2])\n  distancelist = \[]\n  if len(pointList) < 3:\n    print \"ERROR, LESS THAN 3 POINTS FOR REFRENCE. GET A BETTER TRACK! \" + str(len(pointList))\n  for item in pointList: #Does it read from the same frame or a new one?\n    #print item\n    x2 = float(item\[0]\[1])\n    y2 = float(item\[0]\[2])\n    dist = math.hypot(x2-x1, y2-y1)\n    dist = dist+1\n    distancelist.append(dist)\n\n\n\n  sorted_lookup = sorted(enumerate(distancelist), key=lambda i:i\[1])\n\n  index0 = sorted_lookup\[0]\[0]\n  index1 = sorted_lookup\[1]\[0]\n  index2 = sorted_lookup\[2]\[0]\n\n  perc0 = 1 / (sorted_lookup\[0]\[1])\n  perc1 = 1 / (sorted_lookup\[1]\[1])\n  perc2 = 1 / (sorted_lookup\[2]\[1])\n\n  if perc0 == 1:\n    perc1 = 0\n    perc2 = 0\n  perctotal = perc0+perc1+perc2\n\n  Percent0 = perc0 if perctotal == 0 else perc0 / (perctotal)\n  Percent1 = perc1 if perctotal == 0 else perc1 / (perctotal)\n  Percent2 = perc2 if perctotal == 0 else perc2 / (perctotal)\n  x02 = float(pointList\[index0]\[1]\[1])\n  y02 = float(pointList\[index0]\[1]\[2])\n  x12 = float(pointList\[index1]\[1]\[1])\n  y12 = float(pointList\[index1]\[1]\[2])\n  x22 = float(pointList\[index2]\[1]\[1])\n  y22 = float(pointList\[index2]\[1]\[2])\n  x01 = float(pointList\[index0]\[0]\[1])\n  y01 = float(pointList\[index0]\[0]\[2])\n  x11 = float(pointList\[index1]\[0]\[1])\n  y11 = float(pointList\[index1]\[0]\[2])\n  x21 = float(pointList\[index2]\[0]\[1])\n  y21 = float(pointList\[index2]\[0]\[2])\n  xOffset = (((x02-x01) * Percent0) + (( x12-x11) * Percent1) + (( x22-x21) * Percent2))\n  yOffset = (((y02-y01) * Percent0) + (( y12-y11) * Percent1) + ((y22-y21) * Percent2))\n  return \[xOffset, yOffset]\n\n\n\n'''\ndef GetNearestPoints(refpoint,pointList):\n    global tsd\n    #print \"--GetNearestPoint--\"\n    #print pointList\n    #Distance Calculation\n    x1 = float(refpoint\[1])\n    y1 = float(refpoint\[2])\n    distancelist = \[]\n    if len(pointList) < 3:\n      print \"ERROR, LESS THAN 3 POINTS FOR REFRENCE. GET A BETTER TRACK! \" + str(len(pointList))\n    for item in pointList: #Does it read from the same frame or a new one?\n        #print item\n        x2 = float(item\[0]\[1])\n        y2 = float(item\[0]\[2])\n        dist = math.hypot(x2-x1, y2-y1)\n        distancelist.append(dist)\n\n\n    #print distancelist\n    sorted_lookup = sorted(enumerate(distancelist), key=lambda i:i\[1])\n    index0 = sorted_lookup\[0]\[0]\n    index1 = sorted_lookup\[1]\[0]\n    index2 = sorted_lookup\[2]\[0]\n    #print sorted_lookup\n    perc0 = 1 / (sorted_lookup\[0]\[1]+tsd)\n    perc1 = 1 / (sorted_lookup\[1]\[1]+tsd)\n    perc2 = 1 / (sorted_lookup\[2]\[1]+tsd)\n    perctotal = perc0+perc1+perc2\n    Percent0 = perc0 / (perctotal+tsd)\n    Percent1 = perc1 / (perctotal+tsd)\n    Percent2 = perc2 / (perctotal+tsd)\n    x02 = float(pointList\[index0]\[1]\[1])\n    y02 = float(pointList\[index0]\[1]\[2])\n    x12 = float(pointList\[index1]\[1]\[1])\n    y12 = float(pointList\[index1]\[1]\[2])\n    x22 = float(pointList\[index2]\[1]\[1])\n    y22 = float(pointList\[index2]\[1]\[2])\n    x01 = float(pointList\[index0]\[0]\[1])\n    y01 = float(pointList\[index0]\[0]\[2])\n    x11 = float(pointList\[index1]\[0]\[1])\n    y11 = float(pointList\[index1]\[0]\[2])\n    x21 = float(pointList\[index2]\[0]\[1])\n    y21 = float(pointList\[index2]\[0]\[2])\n    #print \"--\"\n    #print pointList\[0]\n    #print \"refpoint\"\n\n    #print x02,y02\n    #print x01,y01\n    #xOffset = (((x02-x1) * Percent0) + (( x12-x1) * Percent1) + (( x22-x1) * Percent2))\n    #yOffset = (((y02-y1) * Percent0) + (( y12-y1) * Percent1) + ((y22-y1) * Percent2))\n\n    xOffset = (((x02-x01) * Percent0) + (( x12-x11) * Percent1) + (( x22-x21) * Percent2))\n    yOffset = (((y02-y01) * Percent0) + (( y12-y11) * Percent1) + ((y22-y21) * Percent2))\n    #print \[xOffset, yOffset]\n    return \[xOffset, yOffset]\n'''\n\n\n#Example 01:\n#This code will extract all tracks from the camera tracker and display the first item.\n\nimport time\n\n#Define Variables\ndebug = 1\nframeForRef = int(nuke.thisNode().knob(\"RefrenceFrameInput\").value())\nStartFrame = int(nuke.thisNode().knob(\"InputFrom\").value())\nEndFrame = int(nuke.thisNode().knob(\"InputTo\").value())\n\nif debug:\n    #Node = nuke.selectedNode()\n    Node = nuke.toNode(\"si_ct\") #change this to your tracker node!\n    NodePin = nuke.toNode(\"si_sw\") #change this to your tracker node!\nelse:\n    Node = nuke.thisNode()\n\n\n#Constants etc.\nRetrun = \[]\ntsd = 0.0000000001 #temp safe devider, me lazy.\nRefPointList = \[\[10.1,10.4],\[0,0]] #temp, delete\n\n\n#01: Get all points from the cameratracker node.\nReturn = ExportCameraTrack(Node)\n#print Return\n#02: To optimize the lookups we index all the data into frame lists containing \[x,y,index,firstframe,lastframe]\n#     this will give a 40+ times performence boost.\nitem_dict = \{\}\nfor list_index, big_lst in enumerate(Return):\n    for lst in big_lst:\n        #print lst\[1:]\n        if lst\[0] in item_dict:\n            item_dict\[lst\[0]] += \[lst\[1:]+\[list_index]+\[Return\[list_index]\[0]\[0], Return\[list_index]\[len(Return\[list_index])-1]\[0]],] # Append\n        else:\n            item_dict\[lst\[0]] = \[lst\[1:]+\[list_index]+\[Return\[list_index]\[0]\[0], Return\[list_index]\[len(Return\[list_index])-1]\[0]],] # Initialize\n\n\n#03: Get a set of reference points. This is the points we want to move.\nRefPointList = GetAnimtionList(Return,item_dict,StartFrame)\n#04: Go through all of the frames and triangulate best points to move the refpoints with.\nstart = time.clock()\nfinalAnimation = \[]\n\n\nprint \"--Initializing Main Loop--\"\n\nfor item in RefPointList:\n  tempAnimation = \[]\n  #print item\n  tempAnimation.append(\[StartFrame,float(item\[0]\[1]),float(item\[0]\[2])])\n  for frame in range(StartFrame,EndFrame):\n\n      newOffset = GetNearestPoints(item\[0],GetAnimtionList(Return,item_dict,frame))\n      tempAnimation.append(\[frame+1,float(item\[0]\[1])+newOffset\[0],float(item\[0]\[2])+newOffset\[1]])\n      item\[0]\[1] = float(item\[0]\[1])+newOffset\[0]\n      item\[0]\[2] = float(item\[0]\[2])+newOffset\[1]\n      #print GetAnimtionList(Return,item_dict,frame)\n      #print str(frame),\" - \", str(item), \" - \", newOffset\n  #print tempAnimation\n  finalAnimation.append(tempAnimation)\nprint \"end\"\n#print finalAnimation\nend = time.clock()\nprint \"%.2gs\" % (end-start)\n\n\nCreateWarpPinPair(NodePin,finalAnimation,frameForRef)\ndel(taskB)"}
 addUserKnob {26 ""}
 addUserKnob {20 Help n 1}
 Help 0
 addUserKnob {26 Info l "" +STARTLINE T "STiCKiT v1.0\n\nPlace the footage that you want to match the motion of into the \[Source] input and hit Analyse.\n\n-Input\n Reference Frame\n     The frame from which you want to apply the operation\n Range\n     The range of frames you want to Analyse\n-Options\n Solve Method\n     The method for solving\n         Triangulation - Use a distance based average of the 3 nearest points\n         Nearest - Single point  \n Apply Method\n     Choose between a match move or warp stabelize\n Filter Method\n     The interpolation method for the warp\n-Analyse"}
 addUserKnob {20 Advanced}
 addUserKnob {20 endGroup n -1}
 addUserKnob {26 Devider_Tracking l "<b><font color=#70EE70>Tracking</font><b>"}
 addUserKnob {41 numberFeatures l "Number of Features" T si_ct.numberFeatures}
 addUserKnob {41 featureThreshold l "Detection Threshold" T si_ct.featureThreshold}
 addUserKnob {41 minTrackLength l "Minimum Length" T si_ct.minTrackLength}
 addUserKnob {41 matchThreshold l "Track Threshold" T si_ct.matchThreshold}
 addUserKnob {41 smoothnessThreshold l "Track Smoothness" T si_ct.smoothnessThreshold}
 addUserKnob {41 consistencyThreshold l "Track Consistency" T si_ct.consistencyThreshold}
 addUserKnob {26 devider_debug l "<b><font color=#70EE70>Other Options</font><b>"}
 addUserKnob {6 displayMotion l "Output Motion Vectors" +STARTLINE}
 displayMotion true
 addUserKnob {6 displayDiffrence l "Output Diffrence Map" +STARTLINE}
 displayDiffrence true
 addUserKnob {6 disableprecrop l "Disable PreCrop" +STARTLINE}
 disableprecrop true
 addUserKnob {26 info l "" +STARTLINE T "Use Diable PreCrop if your overlay footage is being cropped off. \nHowever enable it again if you want to copy / paste the node or \notherwise unplug the overlay input. Due to a bug in nuke all \nkeyframes will be removed if this is not turned on."}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0x4f4f4fff
  note_font_size 42
  xpos -3743
  ypos -1955
  bdwidth 8808
  bdheight 5151
 }
 Input {
  inputs 0
  name InputOverlay
  tile_color 0xff
  xpos 776
  ypos 131
  number 1
 }
 Crop {
  box {0 0 1920 1080}
  name si_prec
  tile_color 0xff
  xpos 776
  ypos 155
  disable {{parent.disableprecrop}}
 }
 Dot {
  name Dot2
  tile_color 0xff
  xpos 810
  ypos 188
 }
set Ne0377e30 [stack 0]
 Dot {
  name Dot3
  tile_color 0xff
  xpos 937
  ypos 188
 }
add_layer {si_mo si_mo.red si_mo.green}
 Expression {
  channel0 {si_mo.red -si_mo.green}
  expr0 x
  channel1 {-si_mo.red si_mo.green}
  expr1 y
  expr2 0
  name si_stgen
  tile_color 0xff
  xpos 903
  ypos 219
 }
set Ne0338c30 [stack 0]
 Dot {
  name Dot4
  tile_color 0xff
  xpos 937
  ypos 498
 }
push $Ne0338c30
push $Ne0377e30
 ShuffleCopy {
  inputs 2
  in si_mo
  alpha alpha2
  black red
  white green
  out2 si_mo
  name si_sh
  tile_color 0xff
  xpos 776
  ypos 219
 }
 SplineWarp3 {
  crop_to_format false
  colorOverlay {0 0 0 0}
  view {}
  curves {{{v x3f99999a}
  {f 0}
  {n
   {layer OverTheSticky
    {f 512}
    {t x44800000 x44428000}
    {a}}}}}
  toolbar_autokey false
  toolbar_preview_mode "persistent preview"
  filter {{parent.FilterMethod}}
  name si_sw
  tile_color 0xff
  xpos 776
  ypos 263
  disable {{parent.DisableWarp}}
 }
set Ne01a3bb0 [stack 0]
 Dot {
  name Dot5
  tile_color 0xff
  xpos 810
  ypos 318
 }
set Ne01b9260 [stack 0]
 Dot {
  name Dot7
  tile_color 0xff
  xpos 810
  ypos 361
 }
set Ne01bd1d0 [stack 0]
 Merge2 {
  inputs 2
  operation minus
  Achannels si_mo
  Bchannels si_mo
  output si_mo
  name si_calcdif
  tile_color 0xff
  xpos 776
  ypos 489
  disable true
 }
push $Ne01a3bb0
add_layer {si_trans si_trans.red si_trans.green si_trans.blue si_trans.alpha}
 Expression {
  channel0 {si_trans.red -si_trans.green -si_trans.blue -si_trans.alpha}
  expr0 si_mo.red/(width-1)
  channel1 {-si_trans.red si_trans.green -si_trans.blue -si_trans.alpha}
  expr1 si_mo.green/(height-1)
  channel2 {-rgba.red -rgba.green -rgba.blue none}
  name si_norm
  tile_color 0xff
  xpos 679
  ypos 495
 }
push $Ne01b9260
push $Ne01a3bb0
 TimeOffset {
  time_offset {{parent.RefrenceFrameInput}}
  time ""
  name si_to
  tile_color 0xff
  xpos 666
  ypos 269
 }
 Merge2 {
  inputs 2
  operation minus
  Achannels si_mo
  Bchannels si_mo
  output si_mo
  name si_calcdisp1
  tile_color 0xff
  xpos 666
  ypos 309
 }
set Ne02013a0 [stack 0]
 Dot {
  name Dot6
  tile_color 0xff
  xpos 700
  ypos 439
 }
push $Ne02013a0
push $Ne01bd1d0
 ShuffleCopy {
  inputs 2
  in si_mo
  alpha alpha2
  black red
  white green
  out2 si_mo
  name si_sh2
  tile_color 0xff
  xpos 626
  ypos 358
 }
 VectorBlur {
  uv si_mo
  name si_mb
  tile_color 0xff
  xpos 516
  ypos 352
  disable {{1-parent.enableMotionBlur}}
 }
 Input {
  inputs 0
  name InputMask
  tile_color 0xff
  xpos 519
  ypos 141
  number 2
 }
 Dot {
  name Dot1
  tile_color 0xff
  xpos 553
  ypos 190
 }
 Input {
  inputs 0
  name InputSource
  tile_color 0xff
  xpos 410
  ypos 142
 }
 CameraTracker {
  inputs 2
  serializeKnob "22 serialization::archive 17 0 4 0 2 0 0 101 0 4 1 1
0 0 1 1 0.375 0 0 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
1 0 1 2 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
2 0 1 3 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
3 0 1 4 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
4 0 1 5 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
5 0 1 6 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
6 0 1 7 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
7 0 1 8 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
8 0 1 9 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
9 0 1 10 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
10 0 1 11 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
11 0 1 12 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
12 0 1 13 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
13 0 1 14 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
14 0 1 15 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
15 0 1 16 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
16 0 1 17 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
17 0 1 18 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
18 0 1 19 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
19 0 1 20 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
20 0 1 21 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
21 0 1 22 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
22 0 1 23 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
23 0 1 24 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
24 0 1 25 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
25 0 1 26 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
26 0 1 27 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
27 0 1 28 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
28 0 1 29 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
29 0 1 30 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
30 0 1 31 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
31 0 1 32 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
32 0 1 33 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
33 0 1 34 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
34 0 1 35 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
35 0 1 36 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
36 0 1 37 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
37 0 1 38 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
38 0 1 39 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
39 0 1 40 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
40 0 1 41 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
41 0 1 42 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
42 0 1 43 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
43 0 1 44 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
44 0 1 45 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
45 0 1 46 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
46 0 1 47 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
47 0 1 48 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
48 0 1 49 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
49 0 1 50 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
50 0 1 51 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
51 0 1 52 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
52 0 1 53 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
53 0 1 54 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
54 0 1 55 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
55 0 1 56 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
56 0 1 57 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
57 0 1 58 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
58 0 1 59 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
59 0 1 60 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
60 0 1 61 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
61 0 1 62 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
62 0 1 63 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
63 0 1 64 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
64 0 1 65 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
65 0 1 66 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
66 0 1 67 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
67 0 1 68 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
68 0 1 69 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
69 0 1 70 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
70 0 1 71 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
71 0 1 72 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
72 0 1 73 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
73 0 1 74 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
74 0 1 75 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
75 0 1 76 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
76 0 1 77 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
77 0 1 78 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
78 0 1 79 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
79 0 1 80 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
80 0 1 81 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
81 0 1 82 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
82 0 1 83 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
83 0 1 84 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
84 0 1 85 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
85 0 1 86 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
86 0 1 87 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
87 0 1 88 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
88 0 1 89 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
89 0 1 90 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
90 0 1 91 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
91 0 1 92 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
92 0 1 93 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
93 0 1 94 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
94 0 1 95 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
95 0 1 96 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
96 0 1 97 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
97 0 1 98 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
98 0 1 99 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
99 0 1 100 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 4
100 0 1 101 0.375 0 0 1919 1079 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 0 0 0 -1 0 0 0 0 0 0 0 0 0 0 -1 0 1 0 4 1 2 0 4 0 4 2 2 0 4 1 4 3 2 0 4 2 4 4 2 0 4 3 4 5 2 0 4 4 4 6 2 0 4 5 4 7 2 0 4 6 4 8 2 0 4 7 4 9 2 0 4 8 4 10 2 0 4 9 4 11 2 0 4 10 4 12 2 0 4 11 4 13 2 0 4 12 4 14 2 0 4 13 4 15 2 0 4 14 4 16 2 0 4 15 4 17 2 0 4 16 4 18 2 0 4 17 4 19 2 0 4 18 4 20 2 0 4 19 4 21 2 0 4 20 4 22 2 0 4 21 4 23 2 0 4 22 4 24 2 0 4 23 4 25 2 0 4 24 4 26 2 0 4 25 4 27 2 0 4 26 4 28 2 0 4 27 4 29 2 0 4 28 4 30 2 0 4 29 4 31 2 0 4 30 4 32 2 0 4 31 4 33 2 0 4 32 4 34 2 0 4 33 4 35 2 0 4 34 4 36 2 0 4 35 4 37 2 0 4 36 4 38 2 0 4 37 4 39 2 0 4 38 4 40 2 0 4 39 4 41 2 0 4 40 4 42 2 0 4 41 4 43 2 0 4 42 4 44 2 0 4 43 4 45 2 0 4 44 4 46 2 0 4 45 4 47 2 0 4 46 4 48 2 0 4 47 4 49 2 0 4 48 4 50 2 0 4 49 4 51 2 0 4 50 4 52 2 0 4 51 4 53 2 0 4 52 4 54 2 0 4 53 4 55 2 0 4 54 4 56 2 0 4 55 4 57 2 0 4 56 4 58 2 0 4 57 4 59 2 0 4 58 4 60 2 0 4 59 4 61 2 0 4 60 4 62 2 0 4 61 4 63 2 0 4 62 4 64 2 0 4 63 4 65 2 0 4 64 4 66 2 0 4 65 4 67 2 0 4 66 4 68 2 0 4 67 4 69 2 0 4 68 4 70 2 0 4 69 4 71 2 0 4 70 4 72 2 0 4 71 4 73 2 0 4 72 4 74 2 0 4 73 4 75 2 0 4 74 4 76 2 0 4 75 4 77 2 0 4 76 4 78 2 0 4 77 4 79 2 0 4 78 4 80 2 0 4 79 4 81 2 0 4 80 4 82 2 0 4 81 4 83 2 0 4 82 4 84 2 0 4 83 4 85 2 0 4 84 4 86 2 0 4 85 4 87 2 0 4 86 4 88 2 0 4 87 4 89 2 0 4 88 4 90 2 0 4 89 4 91 2 0 4 90 4 92 2 0 4 91 4 93 2 0 4 92 4 94 2 0 4 93 4 95 2 0 4 94 4 96 2 0 4 95 4 97 2 0 4 96 4 98 2 0 4 97 4 99 2 0 4 98 4 100 1 0 4 99 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 1 0 0 0 0 0 101 0 0 0 0 0 1 0 0 0 1 0 2 0 2 0 2 0 1 0 3 0 3 0 2 0 2 0 4 0 4 0 2 0 3 0 5 0 5 0 2 0 4 0 6 0 6 0 2 0 5 0 7 0 7 0 2 0 6 0 8 0 8 0 2 0 7 0 9 0 9 0 2 0 8 0 10 0 10 0 2 0 9 0 11 0 11 0 2 0 10 0 12 0 12 0 2 0 11 0 13 0 13 0 2 0 12 0 14 0 14 0 2 0 13 0 15 0 15 0 2 0 14 0 16 0 16 0 2 0 15 0 17 0 17 0 2 0 16 0 18 0 18 0 2 0 17 0 19 0 19 0 2 0 18 0 20 0 20 0 2 0 19 0 21 0 21 0 2 0 20 0 22 0 22 0 2 0 21 0 23 0 23 0 2 0 22 0 24 0 24 0 2 0 23 0 25 0 25 0 2 0 24 0 26 0 26 0 2 0 25 0 27 0 27 0 2 0 26 0 28 0 28 0 2 0 27 0 29 0 29 0 2 0 28 0 30 0 30 0 2 0 29 0 31 0 31 0 2 0 30 0 32 0 32 0 2 0 31 0 33 0 33 0 2 0 32 0 34 0 34 0 2 0 33 0 35 0 35 0 2 0 34 0 36 0 36 0 2 0 35 0 37 0 37 0 2 0 36 0 38 0 38 0 2 0 37 0 39 0 39 0 2 0 38 0 40 0 40 0 2 0 39 0 41 0 41 0 2 0 40 0 42 0 42 0 2 0 41 0 43 0 43 0 2 0 42 0 44 0 44 0 2 0 43 0 45 0 45 0 2 0 44 0 46 0 46 0 2 0 45 0 47 0 47 0 2 0 46 0 48 0 48 0 2 0 47 0 49 0 49 0 2 0 48 0 50 0 50 0 2 0 49 0 51 0 51 0 2 0 50 0 52 0 52 0 2 0 51 0 53 0 53 0 2 0 52 0 54 0 54 0 2 0 53 0 55 0 55 0 2 0 54 0 56 0 56 0 2 0 55 0 57 0 57 0 2 0 56 0 58 0 58 0 2 0 57 0 59 0 59 0 2 0 58 0 60 0 60 0 2 0 59 0 61 0 61 0 2 0 60 0 62 0 62 0 2 0 61 0 63 0 63 0 2 0 62 0 64 0 64 0 2 0 63 0 65 0 65 0 2 0 64 0 66 0 66 0 2 0 65 0 67 0 67 0 2 0 66 0 68 0 68 0 2 0 67 0 69 0 69 0 2 0 68 0 70 0 70 0 2 0 69 0 71 0 71 0 2 0 70 0 72 0 72 0 2 0 71 0 73 0 73 0 2 0 72 0 74 0 74 0 2 0 73 0 75 0 75 0 2 0 74 0 76 0 76 0 2 0 75 0 77 0 77 0 2 0 76 0 78 0 78 0 2 0 77 0 79 0 79 0 2 0 78 0 80 0 80 0 2 0 79 0 81 0 81 0 2 0 80 0 82 0 82 0 2 0 81 0 83 0 83 0 2 0 82 0 84 0 84 0 2 0 83 0 85 0 85 0 2 0 84 0 86 0 86 0 2 0 85 0 87 0 87 0 2 0 86 0 88 0 88 0 2 0 87 0 89 0 89 0 2 0 88 0 90 0 90 0 2 0 89 0 91 0 91 0 2 0 90 0 92 0 92 0 2 0 91 0 93 0 93 0 2 0 92 0 94 0 94 0 2 0 93 0 95 0 95 0 2 0 94 0 96 0 96 0 2 0 95 0 97 0 97 0 2 0 96 0 98 0 98 0 2 0 97 0 99 0 99 0 2 0 98 0 100 0 100 0 2 0 99 0 101 0 101 0 1 0 100 0 0 0 0 0"
  trackDisplay "Points only"
  ignore "Mask Inverted Alpha"
  trackRange Custom
  trackStart {{parent.InputFrom}}
  trackStop {{parent.InputTo+1}}
  referenceFrames {{curve x1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101}}
  filenameSalt 9831
  userTrackViews {left right}
  trackCurves {"num tracks" {curve}
    "track len - min" {curve}
    "track len - avg" {curve}
    "track len - max" {curve}
    "Min Length" {curve x1 0 x101 0}
    "Solve Error" {curve x1 0 x101 0}
    "error - min" {curve}
    "error - rms" {curve}
    "error - track" {curve}
    "error - max" {curve}
    "Max Track Error" {curve x1 0 x101 0}
    "Max Error" {curve x1 0 x101 0}}
  numberFeatures 200
  featureThreshold 0.0001
  featureSeparation 9
  matchThreshold 0.041
  smoothnessThreshold 0.11
  name si_ct
  tile_color 0xff
  xpos 410
  ypos 187
 }
 Shuffle {
  red black
  green black
  blue black
  alpha black
  name si_switch
  tile_color 0xff
  xpos 410
  ypos 274
  disable {{1-parent.HideSource}}
 }
 Merge2 {
  inputs 2
  name si_mrg
  tile_color 0xff
  xpos 410
  ypos 358
 }
add_layer {si_mov si_mov.red si_mov.green si_mov.blue si_mov.alpha}
 ShuffleCopy {
  inputs 2
  in si_mo
  alpha alpha2
  black red
  white green
  red2 black
  green2 black
  out2 si_mov
  name si_mrg_mv
  tile_color 0xff
  xpos 410
  ypos 436
  disable {{1-parent.displayMotion}}
 }
 ShuffleCopy {
  inputs 2
  in si_trans
  alpha alpha2
  black red
  white green
  red2 black
  green2 black
  out2 si_trans
  name si_mrg_st
  tile_color 0xff
  xpos 410
  ypos 495
  disable {{1-parent.displayDiffrence}}
 }
 Output {
  name Output1
  tile_color 0xff
  xpos 410
  ypos 540
 }
 StickyNote {
  inputs 0
  name StickyNote1
  tile_color 0xff
  label "StickIT debug instructions.\n\n\n\nA: Make sure that there is not too much jitter in any of the features\n\nB: Currently Stickit does not support empty frames, all frames within\n    the region must have atleast 3 features.\n\nC: If the warp get crossed, go into the tracker (si_ct) and delete points \n    from the reference frame.\n\n\n\n\n\n\n\n                                                                                                        "
  note_font_size 300
  xpos 5602
  ypos -1393
 }
end_group
push $cut_paste_input
Group {
 name IE_mScatterGeo_v0001_1
 onCreate "\nnuke.thisGroup()\['max_instance'].setFlag(0x00000100)\n"
 tile_color 0x194e7fff
 note_font Verdana
 selected true
 xpos -33531
 ypos 11686
 addUserKnob {20 general l General}
 addUserKnob {26 title_snap l "<b>SNAP SETUP</b>" +INVISIBLE}
 addUserKnob {41 snap_type l "snap type" t "<u>selected vertices/faces</u>\nCreate instance(s) from selected vertices/faces. 'RGB texture' sampling does not support this snap type.\n\n<u>density map (alpha)</u>\nUse alpha channel of sampleGeo as density map. 'RGB texture' sampling supported this snap type." +INVISIBLE T menu02.snap_type}
 addUserKnob {26 title_vf_setting l "<b>vertices/faces setting</b>" +DISABLED +INVISIBLE}
 addUserKnob {7 random_percentage l "random percentage" t "Setup the percentage of the random will apply. The value clipped between 0 to 100." +DISABLED +INVISIBLE R 0.01 100}
 random_percentage 100
 addUserKnob {3 random_seed l seed +DISABLED +INVISIBLE}
 addUserKnob {26 title_dmap_setting l "<b>SCATTER SETTINGS</b>"}
 addUserKnob {78 max_instance l "max instances" t "This can control the maximun instance(s) will be generated, to speed up the process if user only need to generate few instance(s)." n 1}
 max_instance 300
 addUserKnob {3 dmap_seed l "scatter start seed" -STARTLINE}
 dmap_seed 11
 addUserKnob {3 number_of_variations l "scatter variations" t "When the value is larger than 1, several scatter variations will be calculated with different random seeds, starting with the scatter start seed. You will be able to switch between the variations in the created Scatter node."}
 number_of_variations 10
 addUserKnob {4 uv_type l UV t "<u>single tile</u>\nprocess faster.\n\n<u>udim</u>\nwill scan through all the UV tiles before process.\n\n*if not sure what type of UV set in geo, recommend to use 'udim' to scan through all the tiles. Or use my another tool, 'UVEditor', to check." +INVISIBLE M {"single tile (fast)" udim "" "" "" "" "" "" ""}}
 addUserKnob {3 sample_res l "texture sample resolution" t "This resolution setting to control the spacing between each instance. Higher solution will get more sample points in UV. Lower solution will get less sample points in UV."}
 sample_res 4096
 addUserKnob {4 rotation_type l "scatter point orientation" t "Rotation type of the snap geo.\n\n<u>lookAt axis/camera</u>\ninstance rotation base on the input axis/camera direction. Axis/Camera input will be created in the generate group.\n\n<u>face normal</u>\ninstance rotation base on the geo surface." +INVISIBLE M {"lookAt axis/camera" "vertices/faces normal" "" "" "" "" "" "" "" ""}}
 addUserKnob {3 fail_attempts l "fail attempts" t "set how many times to retry if they fail on sampling. When max instances are larger than available samples, then the sample process will fall into a loop hole. So value limited the retry attempts.\n\n\n- lower value can get faster but may not meet the max instances value.\n\n\n- higher value can meet the max instance value but might take longer time to retry the sampling.\n\n\nWhat makes the sampling fail?\nposition+range size already existing in the sample data.\n\n" +INVISIBLE}
 fail_attempts 500
 addUserKnob {4 rgb_color l "RGB texture color" t "Sample color from 'sampleGeo' texture input and generated with instance(s).\n\n<u>sample premult RGB</u>\nsemi-transparent pixels will get darker color on generated instance, but the color is 100% match to the sampled texture color.\n\n<u>sample unpremult RGB</u>\nThis can avoid dark color on semi-transparent pixels." +INVISIBLE M {"not selected" "sample premult RGB" "sample unpremult RGB" "" "" ""}}
 addUserKnob {26 spacer l "" +STARTLINE T <br>}
 addUserKnob {26 title_rotate l "<b>ROTATION SETUP</b>" +INVISIBLE}
 addUserKnob {26 title_input l "<b>INPUT SETTINGS</b>"}
 addUserKnob {41 var_type l "input type" t "select the input variation type.\n\n<u>Framehold</u>\nrandom pick a still frame of texture & geo.\n\n<u>Timeoffset</u>\nrandom pick the start frame of texture sequence and animated geo." T menu01.var_type}
 addUserKnob {3 frame_start l "input frame range"}
 frame_start 1001
 addUserKnob {3 frame_end l "" -STARTLINE}
 frame_end 1012
 addUserKnob {3 offset_start l "offset range" +HIDDEN +INVISIBLE}
 addUserKnob {3 offset_end2 l "" -STARTLINE +INVISIBLE}
 offset_end2 300
 addUserKnob {7 offset_end l "max frame offset" +HIDDEN R 0 500}
 offset_end 230
 addUserKnob {26 spacer_3 l "" +STARTLINE T <br>}
 addUserKnob {26 spacer11 l "" +STARTLINE T <br>}
 addUserKnob {22 generate l "<b>\[--- GENERATE ---]</b>" t "Generate group named 'mSnap'" T "thisGRP = nuke.thisGroup()\n\ntry:\n   ##### get functions and values\n   goStore = nuke.toNode('store')\n   goStore\['fn01'].execute()\n   goStore\['fn02'].execute()\n   filterCheck = goStore\['filterNonReverse'].getValue().split(',')\n   filter3DNodes = goStore\['filter3DNodes'].value().split(',')\n   filterPrimitives = goStore\['filterPrimitives'].value().split(',')\n\n   uvStart = nuke.toNode('uv_dot')\n   ##### remove prep nodes\n   rmNodes(uvStart)\n\n   curveTool = nuke.toNode('CurveTool')\n   texRes = int(thisGRP\['sample_res'].value())\n   maxIns = thisGRP\['max_instance'].getValue()\n\n   if texRes > 32:\n      ##### find map data on tile\n      samNodes = scanTile(thisGRP, uvStart, curveTool, texRes)\n\n      if len(samNodes):\n         ##### find the sum of area\n         totalArea = 0\n         for samNode in samNodes:\n            totalArea += samNode.width() * samNode.height()\n\n         if maxIns < totalArea:\n            ##### find tile proportion\n            tileData = \{\}\n            for samNode in samNodes :\n               samCount = int( round( ( samNode.width() * samNode.height() ) / totalArea * maxIns ) )\n               tileData\[samNode.name()] = \[samNode, samCount]\n\n            ##### process\n            # Add progress bar for variations\n            progBar = nuke.ProgressTask('Creating Scatter Setup')\n            progBar.setProgress(0)\n            progBar.setMessage(\"Sampling Geometry\")\n            jobCount = 0\n            jobTotal = int(thisGRP\['number_of_variations'].getValue()) + 1\n\n            # IE ADD PROCESS FOR SEVERAL ptsIDs\n            ptsID = samID(thisGRP, tileData)\n            starting_seed = thisGRP\['random_seed'].getValue()\n            number_of_variations = int(thisGRP\['number_of_variations'].getValue())\n\n            ptsID_variations_list = \[]\n            for seed_adjustment in range(0, number_of_variations):\n               progBar.setMessage(\"Sampling Positions for Variations\")\n               variation_seed = starting_seed + seed_adjustment\n               ptsID_variations_list.append(samID(thisGRP, tileData, random_seed=variation_seed))\n               if progBar.isCancelled():\n                  break;\n               jobCount += 1\n               progBar.setProgress(int(jobCount / jobTotal * 100))\n\n            progBar.setMessage(\"Creating Scatter Nodes\")\n            genDMap( thisGRP , ptsID_variations_list , samNodes )\n            progBar.setProgress(100)\n            del progBar\n\n            ##### remove prep nodes\n            rmNodes(uvStart)\n         else :\n            nuke.message(\"'max instance(s)'' <font color='red'>larger</font> than detected sample area.<br><br>\"\n                      \"Try to <font color=orange>reduce</font> 'max instance(s)' or <font color=orange>increase\"\n                      \"</font> 'sample resolution' to process again.<br><br>Process denied...\")\n            ##### remove prep nodes\n            rmNodes( uvStart )\n      else :\n         nuke.message('No UV data detected.<br><br>Process denied...')\n   else :\n      nuke.message('sample resolution cannot set lower than 32.<br><br>Process denied...')\n\nexcept UnboundLocalError :\n   nuke.message('No available input found. Input required 3D geo.<br><br>Process denied...')" +STARTLINE}
 addUserKnob {6 with_animation l "with animated geo" -STARTLINE +INVISIBLE}
 addUserKnob {22 selected_vertex_info l "selected vertex info" t "get the vertices/faces info." +DISABLED +INVISIBLE T "thisGRP = nuke.thisGroup()\npyg = nuke.toNode('PythonGeo')\n\n##### get functions\ngoStore = nuke.toNode('store')\ngoStore\['fn01'].execute()\ngoStore\['fn02'].execute()\n\nfilter3DNodes = goStore\['filter3DNodes'].value().split(',')\nfilterPrimitives = goStore\['filterPrimitives'].value().split(',')\n\nmainstream = upstreamNodes( thisGRP , filter3DNodes )\n\ndisabledNodes = \[]\nfor lvl01 in mainstream :\n  for lvl02 in lvl01 :\n    if lvl02\['disable'].getValue() :\n      disabledNodes.append( lvl02.name() )\n\n##### check disable nodes\nif len( disabledNodes ) :\n  nuke.message( 'Disabled node(s) :<p><font color=red>\{0\}</font><p>Please disconnect these transformation nodes from the tree.'.format( '<br>'.join(disabledNodes) ) )\n\nelse :\n  ##### find primary geo\n  mainGeo = primaryGeo( mainstream , filterPrimitives )\n\n  ##### get selected ID\n  ptsID = selID()\n\n  if len( ptsID ) == 0 :\n    facesVTX = \[]\n    for key,value in enumerate( mainGeo\['geo_select'].getSelectedFaces()\[0] ) :\n      if value :\n        facesVTX.append( geoPrims( mainGeo )\[key] )\n    ptsID = facesVTX\n    selType = 1\n  else :\n    selType = 0\n\n  ptsID = randSelID( ptsID , thisGRP )\n\n  gData = geoData( pyg , 0 ) ##### get geo data\n\n  info = \['<b><font color=orange>geo total vertex : </font></b>' + str( len(gData) ) , '<b><font color=orange>total selected vertex : </font></b>' + str( len(ptsID) ) , '' ]\n  print ('total vertex : ' + str(len(gData)))\n  for i in ptsID :\n    if type(i) == str :\n      info.append( '<b><font color=orange>selected geo type : </font></b>vertex' )\n      info.append( '<b><font color=orange>primitives : </font></b>' + str( i.split('_')\[1:]\[0] ) )\n      info.append( '<b><font color=orange>vertex (pos|nor) : </font></b>' + str( gData\[i] ) )\n    else :\n      if len(i) == 3 :\n        info.append( '<b><font color=orange>selected geo type : </font></b>3-sides' )\n      elif len(i) == 4 :\n        info.append( '<b><font color=orange>selected geo type : </font></b>4-sides' )\n      else :\n        info.append( '<b><font color=orange>selected geo type : </font></b>N-sides' )\n\n      for prim in i :\n        info.append( '<b><font color=orange>vertex ID : </font></b>' + str( prim ) )\n        info.append( '<b><font color=orange>vertex (pos|nor) : </font></b>' + str( gData\['0_' + str( prim )] ) )\n\n    info.append( '' )\n    info.append( '===================' )\n    info.append( '' )\n\np = nuke.Panel( 'Selected vertex info :' )\np.addNotepad( '', '<br>'.join( info ) )\np.setWidth(1200)\np.show()" +STARTLINE}
 addUserKnob {26 title_selection l "<i>( optional )</i>" +INVISIBLE T "<b>save selected vertices / faces</b>"}
 addUserKnob {41 geo T GeoSelect.geo}
 addUserKnob {22 save_selection l "save selection" +INVISIBLE T "if nuke.thisGroup().inputs() :\n\tnuke.thisGroup()\['hidden_btn'].execute()\n\tnuke.thisGroup()\['savedata'].setValue( nuke.thisGroup()\['geo'].toScript() )\nelse :\n\tnuke.message('Save selection fail.<br>No inputs found.<br>Please connect this node to geo.')" +STARTLINE}
 addUserKnob {41 hidden_btn l "" +STARTLINE +INVISIBLE T GeoSelect.save_selection}
 addUserKnob {41 restore_selection l "restore selection" -STARTLINE +INVISIBLE T GeoSelect.restore_selection}
 addUserKnob {22 reset_selection l "reset selection" -STARTLINE +INVISIBLE T "nuke.thisGroup()\['geo'].fromScript('')\nnuke.thisGroup()\['savedata'].setValue('')"}
 addUserKnob {20 selection_data l "selection data" +INVISIBLE n 1}
 addUserKnob {43 savedata l "saved data" +DISABLED}
 addUserKnob {20 endGroup n -1}
 addUserKnob {20 t_VERSION l Version}
 addUserKnob {26 ie_version_info l "IE Version "}
 addUserKnob {26 ie_version l Version T 1.02}
 addUserKnob {26 ie_date_modified l "Date Modified" T 2021-12-20}
 addUserKnob {26 text_1 l Documentation T "<a href='http://docsie/index.php/MScatterGeo'><font color='orange'>Docsie</font></a>"}
 addUserKnob {26 version_spacer l " " T " "}
 addUserKnob {26 original_version_info l "Original Version"}
 addUserKnob {26 l_VERSION l Version T 1.4}
 addUserKnob {26 l_DATE l "Date Modified" T 2021-03-23}
 addUserKnob {22 btn_CHANGELOG l Changelog T "log = \"1.4<br>-&nbsp;added&nbsp;'fail&nbsp;attempts'&nbsp;knob.&nbsp;(check&nbsp;tooltips)<br>-&nbsp;UV&nbsp;type&nbsp;set&nbsp;'single&nbsp;tile'&nbsp;by&nbsp;default<br><br>1.3<br>-&nbsp;compatible&nbsp;with&nbsp;python3<br>-&nbsp;fix&nbsp;'selected&nbsp;vertex&nbsp;info'&nbsp;button&nbsp;(it&nbsp;broke&nbsp;on&nbsp;last&nbsp;version)<br>-&nbsp;panel&nbsp;UI&nbsp;update<br><br>1.2<br>-&nbsp;Since&nbsp;generated&nbsp;group&nbsp;changed&nbsp;to&nbsp;'mSnap',&nbsp;<br>&nbsp;&nbsp;it&nbsp;breaks&nbsp;the&nbsp;unique&nbsp;name&nbsp;check,&nbsp;fixed&nbsp;on&nbsp;1.2&nbsp;.<br>-&nbsp;Added&nbsp;density&nbsp;map&nbsp;feature&nbsp;(alpha).<br>-&nbsp;Added&nbsp;RGB&nbsp;as&nbsp;texture&nbsp;color&nbsp;feature.<br>-&nbsp;Correct&nbsp;title&nbsp;name&nbsp;on&nbsp;tool's&nbsp;panel&nbsp;('texture&nbsp;setup'&nbsp;to&nbsp;input&nbsp;'setup').<br>-&nbsp;Minor&nbsp;fix&nbsp;normal&nbsp;to&nbsp;rotate&nbsp;algorithm&nbsp;(x&nbsp;rotation&nbsp;when&nbsp;-y&-z).<br>-&nbsp;Removed&nbsp;random&nbsp;selection&nbsp;checkbox.<br>&nbsp;&nbsp;&nbsp;*If&nbsp;don't&nbsp;need&nbsp;random&nbsp;selection,&nbsp;just&nbsp;keep&nbsp;random&nbsp;percentage=100.<br>-&nbsp;Adjust&nbsp;some&nbsp;backend&nbsp;code.<br>-&nbsp;'mScap'&nbsp;group&nbsp;added&nbsp;group&nbsp;info&nbsp;tab.<br>-&nbsp;Input&nbsp;of&nbsp;'mScatterGeo'&nbsp;changed&nbsp;name&nbsp;from&nbsp;'Geo'&nbsp;to&nbsp;'sampleGeo'.<br>-&nbsp;Fix&nbsp;rotation&nbsp;X&nbsp;under&nbsp;snap&nbsp;with&nbsp;normal&nbsp;rotation.<br>&nbsp;&nbsp;So&nbsp;it&nbsp;match&nbsp;to&nbsp;input&nbsp;geo&nbsp;origin.<br>-&nbsp;Fix&nbsp;ReadGeo's&nbsp;vertex&nbsp;normal&nbsp;rotation.<br>-&nbsp;Added&nbsp;delete&nbsp;instance&nbsp;on&nbsp;'mSnap'&nbsp;group.<br>-&nbsp;Added&nbsp;'select&nbsp;all'&nbsp;button&nbsp;on&nbsp;'mSnap'&nbsp;group.<br><br>1.1<br>-&nbsp;'MassiveSnapGeo'&nbsp;generated&nbsp;group&nbsp;renamed&nbsp;to&nbsp;'mSnap'<br>-&nbsp;fix&nbsp;slider&nbsp;UI&nbsp;after&nbsp;re-open&nbsp;nuke&nbsp;script&nbsp;on&nbsp;'mSnap'<br>-&nbsp;added&nbsp;display&nbsp;snap&nbsp;axis<br>-&nbsp;added&nbsp;extract&nbsp;axis<br><br>1.0<br>-&nbsp;re-work&nbsp;the&nbsp;unrelease&nbsp;version&nbsp;in&nbsp;2018\"\nnuke.message( log )" +STARTLINE}
 addUserKnob {26 l_DEV l "Developed by" T "<a href='https://youtube.com/c/MJTLab'><font color='orange'>Mark Joey Tang</font></a>"}
 addUserKnob {20 ieAssetInfo l "Asset Information"}
 addUserKnob {20 Advanced t "\n<B>ieEntityType:</B> NukeScriptletPackage\n<B>ieEntityId:</B> 2836843.0\n<B>ieAssetId:</B> 0.0\n<B>ieCopyId:</B> 1\n<B>ieNodeTag:</B> \n<B>ieLinkedEntities:</B> \[]\n<B>ieBundleId:</B> 0.0" n 2}
 addUserKnob {1 ieNodeType l "Node Type" +INVISIBLE}
 ieNodeType assetNode
 addUserKnob {1 ieEntityType l "Entity Type" +DISABLED}
 ieEntityType NukeScriptletPackage
 addUserKnob {3 ieEntityId l "Entity Id" +DISABLED}
 ieEntityId 2836843
 addUserKnob {3 ieAssetId l "Asset Id" +DISABLED}
 addUserKnob {1 ieCopyId l "Copy Id" +DISABLED}
 ieCopyId 1
 addUserKnob {1 ieNodeTag l "Node Tag" +DISABLED}
 addUserKnob {1 ieLinkedEntities l "Linked Entities" +DISABLED}
 ieLinkedEntities "\[]"
 addUserKnob {3 ieBundleId l "Bundle Id" +DISABLED}
 addUserKnob {20 AdvancedEG n -1}
 addUserKnob {3 ieBundleVersion l "<span style=\"color:Silver\">Bundle Version </span>" t "\nThis entity is not part\nof a bundle." +DISABLED}
 addUserKnob {1 ieDisplayName l Name +DISABLED}
 ieDisplayName IE_mScatterGeo
 addUserKnob {4 ieEntityVersion l "Entity Version" M {1}}
 addUserKnob {32 ieUpdateVersions l "Update Versions" -STARTLINE}
 addUserKnob {1 ieVersionCreationDate l "Version Creation Date" +DISABLED}
 ieVersionCreationDate "02-09-2022 12:20:29"
 addUserKnob {1 ieVersionCreator l Artist -STARTLINE +DISABLED}
 ieVersionCreator danielsc
 addUserKnob {4 ieUpdateMode l "Update Mode" M {locked latest latestApproved default}}
 ieUpdateMode default
 addUserKnob {6 ieRelativeToLocation l "Entity is Dynamic - Relative To Environment Location" +STARTLINE}
 addUserKnob {32 ieSourceScene l "Open Source Scene" +STARTLINE}
 addUserKnob {26 ieSeparator l "  "}
}
 BackdropNode {
  inputs 0
  name BackdropNode1
  tile_color 0xff
  label "dont touch"
  note_font_size 42
  xpos -510
  ypos -41
  bdwidth 232
  bdheight 407
 }
 BackdropNode {
  inputs 0
  name BackdropNode2
  tile_color 0x848484ff
  label bin
  note_font_size 42
  xpos -241
  ypos -42
  bdwidth 307
  bdheight 637
 }
 Input {
  inputs 0
  name sampleGeo
  xpos 138
  ypos -38
 }
 Dot {
  name Dot1
  xpos 172
  ypos 64
 }
 GeoSelect {
  inputs 0
  selectable false
  geo {  }
  name GeoSelect
  xpos 138
  ypos 215
 }
 Output {
  name Output1
  xpos 138
  ypos 724
 }
 NoOp {
  inputs 0
  name menu02
  knobChanged "\nthisGRP = nuke.thisGroup()\ndmapknobs = \['title_dmap_setting','uv_type','sample_res','max_instance','dmap_seed','rgb_color','fail_attempts']\nvtxknobs = \['title_vf_setting','random_percentage','random_seed']\nif thisGRP\['snap_type'].getValue() :\n    for knob in dmapknobs :\n        thisGRP\[knob].setEnabled( True )\n    for knob in vtxknobs :\n        thisGRP\[knob].setEnabled( False )\n    thisGRP\['selected_vertex_info'].setEnabled( False )\nelse :\n    for knob in dmapknobs :\n        thisGRP\[knob].setEnabled( False )\n    for knob in vtxknobs :\n        thisGRP\[knob].setEnabled( True )\n    thisGRP\['selected_vertex_info'].setEnabled( True )\n"
  xpos -447
  ypos 127
  addUserKnob {20 User}
  addUserKnob {4 snap_type l "snap type" M {"selected vertices/faces" "density map (alpha)"}}
  snap_type "density map (alpha)"
 }
 Normals {
  inputs 0
  display off
  selectable false
  action build
  threshold 0
  name Normals
  xpos 292
  ypos 61
  disable true
 }
 Dot {
  name Dot2
  xpos 326
  ypos 141
 }
set Nf8cc7300 [stack 0]
 PythonGeo {
  name PythonGeo
  xpos 292
  ypos 218
 }
 CurveTool {
  inputs 0
  operation "Auto Crop"
  channels alpha
  ROI {0 0 32 32}
  autocropdata {0 0 32 32}
  name CurveTool
  xpos -130
  ypos 129
 }
push $Nf8cc7300
 Dot {
  name Dot3
  xpos 491
  ypos 141
 }
 Reformat {
  inputs 0
  type "to box"
  box_width {{"\[value parent.sample_res]"}}
  box_height {{"\[value parent.sample_res]"}}
  box_fixed true
  name Reformat1
  xpos 599
  ypos 322
 }
add_layer {pos pos.red pos.green pos.blue pos.alpha}
add_layer {nor nor.red nor.green nor.blue}
 ScanlineRender {
  inputs 2
  conservative_shader_sampling false
  projection_mode uv
  overscan {{"\[value parent.sample_res] * 9"}}
  motion_vectors_type off
  MB_channel none
  output_shader_vectors true
  P_channel pos
  N_channel nor
  name uvRender
  xpos 457
  ypos 322
 }
 Remove {
  operation keep
  channels rgba
  channels2 {pos.red pos.green pos.blue none}
  channels3 nor
  name Remove
  xpos 457
  ypos 402
 }
 Unpremult {
  name Unpremult1
  xpos 457
  ypos 482
  disable {{"parent.rgb_color == 1 ? 1 : 0"}}
 }
 Crop {
  box {0 0 {"\[value parent.sample_res] * 10"} {"\[value parent.sample_res] * 10"}}
  name UV1010
  xpos 457
  ypos 562
  addUserKnob {20 BBox}
  addUserKnob {41 Bbox T this.box}
  addUserKnob {41 softnessB l softness T this.softness}
  addUserKnob {41 reformatB l reformat T this.reformat}
  addUserKnob {41 cropB l "black outside" -STARTLINE T this.crop}
  addUserKnob {26 space l "" +STARTLINE T "    "}
  addUserKnob {22 Format l "Format Size" -STARTLINE T "n = nuke.thisNode()\n\n#getInput Values\nfX1 = n.input(0).format().x()\nfY1 = n.input(0).format().y()\nfX2 = n.input(0).format().width()\nfY2 = n.input(0).format().height()\n\n#add percent\npercent = n\['percent'].value()\nXpercent = ((fX2-fX1)*percent)/100\nYpercent = ((fY2-fY1)*percent)/100\n\nfX1 = fX1-Xpercent\nfY1 = fY1-Ypercent\nfX2 = fX2+Xpercent\nfY2 = fY2+Ypercent\n\nfX1 = int(fX1)\nfX2 = int(fX2)\nfY1 = int(fY1)\nfY2 = int(fY2)\n\nn\['box'].setValue((fX1,fY1,fX2,fY2))"}
  addUserKnob {22 BBFormat l "BB Format Size" -STARTLINE T "n = nuke.thisNode()\n\n#getInput Values\nfX1 = n.input(0).bbox().x()\nfY1 = n.input(0).bbox().y()\nfX2 = n.input(0).bbox().w()+fX1\nfY2 = n.input(0).bbox().h()+fY1\n\n#add percent\npercent = n\['percent'].value()\nXpercent = ((fX2-fX1)*percent)/100\nYpercent = ((fY2-fY1)*percent)/100\n\nfX1 = fX1-Xpercent\nfY1 = fY1-Ypercent\nfX2 = fX2+Xpercent\nfY2 = fY2+Ypercent\n\nfX1 = int(fX1)\nfX2 = int(fX2)\nfY1 = int(fY1)\nfY2 = int(fY2)\n\nn\['box'].setValue((fX1,fY1,fX2,fY2))"}
  addUserKnob {22 BBMaxFormat l "BB Max Format Size" -STARTLINE T "n = nuke.thisNode()\n\n\n#getInput format Values\nfX1 = n.input(0).format().x()\nfY1 = n.input(0).format().y()\nfX2 = n.input(0).format().width()\nfY2 = n.input(0).format().height()\n\n#getInput BB Values\nBBfX1 = n.input(0).bbox().x()\nBBfY1 = n.input(0).bbox().y()\nBBfX2 = n.input(0).bbox().w()+BBfX1\nBBfY2 = n.input(0).bbox().h()+BBfY1\n\nif abs(BBfX1-fX1)<abs(BBfX2-fX2) :\n\tBBfX1=fX1-abs(BBfX2-fX2)\nelse :\n\tBBfX2=fX2+abs(BBfX1-fX1)\n\nif abs(BBfY1-fY1)<abs(BBfY2-fY2) :\n\tBBfY1=fY1-abs(BBfY2-fY2)\nelse :\n\tBBfY2=fY2+abs(BBfY1-fY1)\n\n\n#add percent\npercent = n\['percent'].value()\nXpercent = ((BBfX2-BBfX1)*percent)/100\nYpercent = ((BBfY2-BBfY1)*percent)/100\n\nfX1 = BBfX1-Xpercent\nfY1 = BBfY1-Ypercent\nfX2 = BBfX2+Xpercent\nfY2 = BBfY2+Ypercent\n\nfX1 = int(fX1)\nfX2 = int(fX2)\nfY1 = int(fY1)\nfY2 = int(fY2)\n\nn\['box'].setValue((fX1,fY1,fX2,fY2))"}
  addUserKnob {7 percent l "Add Percent" R 0 100}
 }
 Clamp {
  channels rgba
  name Clamp1
  xpos 457
  ypos 642
 }
 Dot {
  name uv_dot
  tile_color 0xff0000ff
  xpos 491
  ypos 722
 }
 NoOp {
  inputs 0
  name menu01
  knobChanged "\nif nuke.thisGroup()\['var_type'].getValue() == 0.0 :\n    nuke.thisGroup()\['frame_start'].setVisible(True)\n    nuke.thisGroup()\['frame_end'].setVisible(True)\n    nuke.thisGroup()\['offset_start'].setVisible(False)\n    nuke.thisGroup()\['offset_end'].setVisible(False)\nelif nuke.thisGroup()\['var_type'].getValue() == 1.0 :\n    nuke.thisGroup()\['frame_start'].setVisible(False)\n    nuke.thisGroup()\['frame_end'].setVisible(False)\n    nuke.thisGroup()\['offset_start'].setVisible(True)\n    nuke.thisGroup()\['offset_end'].setVisible(True)\nelse :\n    nuke.thisGroup()\['frame_start'].setVisible(False)\n    nuke.thisGroup()\['frame_end'].setVisible(False)\n    nuke.thisGroup()\['offset_start'].setVisible(False)\n    nuke.thisGroup()\['offset_end'].setVisible(False)\n"
  xpos -444
  ypos 64
  addUserKnob {20 User}
  addUserKnob {4 var_type l "variation type" M {Turntable "Image Sequence" "" ""}}
 }
 NoOp {
  inputs 0
  name store
  selected true
  xpos -135
  ypos 61
  addUserKnob {20 User}
  addUserKnob {22 fn01 T "import math\nimport random\nimport time\n\n\n##### mode 0 = lookAt camera || 1 = vertices/faces normal || 2 = density map\n\ndef failCHK(_thisG, _failClass):\n    curNode = thisGRP\n    fail = 0\n    while curNode:\n        if curNode.Class() in _failClass:\n            fail = 1\n        curNode = curNode.input(0)\n    return fail\n\ndef grouper(_n, _iterable):\n    import itertools\n    args = \[iter(_iterable)] * _n\n    try:\n        return itertools.zip_longest(*args)\n    except AttributeError:\n        return itertools.izip_longest(*args)\n\ndef geoData(_pyNode, _objnum):\n    ptsID = \[]\n    for i in _pyNode\['geo'].getGeometry()\[_objnum].primitives():\n        for j in i:\n            if ptsID.count(j) == 0:\n                ptsID.append(j)\n\n    ptsID.sort()\n\n    vtxPos = list(grouper(3, list(_pyNode\['geo'].getGeometry()\[_objnum].points())))\n    vtxNor = list(grouper(3, list(_pyNode\['geo'].getGeometry()\[_objnum].normals())))\n\n    geoFullset = \{\}\n    for i in ptsID:\n        geoFullset\[str(_objnum) + '_' + str(i)] = \[vtxPos\[i], vtxNor\[i]]\n\n    return geoFullset\n\ndef findAvailableName(_name):\n    findName = 0\n    detectName = \[]\n\n    for node in nuke.allNodes():\n        if node.name().split('_')\[0] == _name:\n            detectName.append(int(node.name().split('_')\[1]))\n    detectName.sort()\n    while detectName.count(findName) != 0:\n        findName += 1\n\n    return findName\n\ndef makePackage(_name, _thisG):\n    xspace = int(nuke.toNode('preferences')\['GridWidth'].getValue())\n\n    # now using different values for turntable/img sequence use\n    texRNG = \[_thisG\['frame_start'].getValue(), _thisG\['frame_end'].getValue()]\n    seqRNG = \[_thisG\['offset_start'].getValue(), _thisG\['offset_end'].getValue()]\n\n    ##### make group\n    availableName = findAvailableName(_name)\n    newName = _name + '_' + str(availableName)\n    random.seed(int(time.time()))\n    snapGRP = nuke.nodes.Group(\n        name=newName,\n        tile_color=int(thisGRP\['tile_color'].getValue()),\n        xpos=thisGRP.xpos() + (xspace + random.randint(0, xspace)),\n        ypos=thisGRP.ypos()\n    )\n\n    snapGRP.addKnob(nuke.Tab_Knob('tab_general', 'General'))\n\n    snapGRP.addKnob(nuke.Link_Knob('display_geo', 'display'))\n    snapGRP\['display_geo'].setLink('MassiveScene.display')\n    snapGRP.addKnob(nuke.Link_Knob('render_geo', 'render'))\n    snapGRP\['render_geo'].setLink('MassiveScene.render_mode')\n\n    snapGRP.addKnob(nuke.Text_Knob('spacer1', '', '<br>'))\n\n    snapGRP.addKnob(nuke.Text_Knob('title_random_tex', '<b>RANDOMIZE INPUT</b>'))\n    snapGRP.addKnob(nuke.Enumeration_Knob(\"input_type\", \"Input Type\", \['Turntable', 'Image Sequence']))\n    snapGRP\['input_type'].setValue(int(_thisG\['var_type'].getValue()))\n\n    snapGRP.addKnob(nuke.Int_Knob('range_start', 'inputs frame range'))\n    snapGRP\['range_start'].setValue(int(texRNG\[0]))\n    snapGRP.addKnob(nuke.Int_Knob('range_end', ''))\n    snapGRP\['range_end'].setValue(int(texRNG\[1]))\n    snapGRP\['range_end'].clearFlag(nuke.STARTLINE)\n    # ALSO adding inputs for the img seq UI\n    snapGRP.addKnob(nuke.Int_Knob('offset_end', 'max frame offset'))\n    snapGRP\['offset_end'].setValue(int(seqRNG\[1]))\n    # set visibilities\n    if _thisG\['var_type'].getValue() == 0.0:\n        snapGRP\['offset_end'].setVisible(False)\n    else:\n        snapGRP\['range_start'].setVisible(False)\n        snapGRP\['range_end'].setVisible(False)\n\n    snapGRP.addKnob(nuke.Int_Knob('tex_seed', 'input seed'))\n\n    # IE add channel list and layer #\n    snapGRP.addKnob(nuke.Enumeration_Knob(\"linked_input_layer_list\", \"input layer list\", \[]))\n    snapGRP\[\"linked_input_layer_list\"].setFlag(nuke.SAVE_MENU)\n    # snapGRP\[\"linked_input_layer_list\"].setFlag(nuke.DISABLED)\n    snapGRP.addKnob(nuke.Int_Knob(\"number_of_layers\", \"\", 0))\n    snapGRP\['number_of_layers'].clearFlag(nuke.STARTLINE)\n    snapGRP\[\"number_of_layers\"].setFlag(nuke.DISABLED)\n    # Add Create-VegetationLoader button\n    snapGRP.addKnob(nuke.PyScript_Knob('create_vegLoader', 'create VegetationLoader', goStore\['cpCode10'].value()))\n    snapGRP.knob('create_vegLoader').setTooltip(\"Creates new Vegetation Loader node and links it to this node's input layer list\")\n\n    snapGRP.addKnob(nuke.Text_Knob('spacer2', '', '<br>'))\n\n    # IE Add Random Seed Controller\n    snapGRP.addKnob(nuke.Text_Knob('title_random', '<b>RANDOMIZE POSITION</b>'))\n    max_variation_index = int(_thisG\['number_of_variations'].getValue()) - 1\n    snapGRP.addKnob(nuke.Text_Knob('scatter_variation_info', ' ',\n                                   '<i>\{0\} variations available (position seed 0 - \{1\})</i>'.format(\n                                       max_variation_index + 1, max_variation_index)))\n\n    snapGRP.addKnob(nuke.Int_Knob('seed_controller', 'position seed'))\n    snapGRP\['seed_controller'].setRange(0,max_variation_index)\n\n    snapGRP.addKnob(nuke.Text_Knob('spacer3', '', '<br>'))\n\n    snapGRP.addKnob(nuke.Text_Knob('title_random_trans', '<b>RANDOMIZE FORMATION</b>'))\n\n    # Lookat Overrides so that we can still have some randomizing when using the lookat\n    snapGRP.addKnob(nuke.Text_Knob('lookAt_override_label', 'LookAt Rotation Overrides', ' '))\n    snapGRP.addKnob(nuke.Boolean_Knob('lookAt_override_x', 'x'))\n    snapGRP.addKnob(nuke.Boolean_Knob('lookAt_override_y', 'y'))\n    snapGRP.addKnob(nuke.Boolean_Knob('lookAt_override_z', 'z'))\n    snapGRP\['lookAt_override_x'].clearFlag(nuke.STARTLINE)\n    snapGRP\['lookAt_override_y'].clearFlag(nuke.STARTLINE)\n    snapGRP\['lookAt_override_z'].clearFlag(nuke.STARTLINE)\n    # all on by default to match transform Geos\n    snapGRP\['lookAt_override_x'].setValue(1)\n    snapGRP\['lookAt_override_y'].setValue(1)\n    snapGRP\['lookAt_override_z'].setValue(1)\n\n    snapGRP.addKnob(nuke.Array_Knob('rotateX_range', 'rotate X range'))\n    snapGRP\['rotateX_range'].setFlag(0x00000002)\n    snapGRP.addKnob(nuke.Array_Knob('rotateX_seed', 'seed'))\n    snapGRP\['rotateX_seed'].clearFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Array_Knob('rotateY_range', 'rotate Y range'))\n    snapGRP\['rotateY_range'].setFlag(0x00000002)\n    snapGRP.addKnob(nuke.Array_Knob('rotateY_seed', 'seed'))\n    snapGRP\['rotateY_seed'].clearFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Array_Knob('rotateZ_range', 'rotate Z range'))\n    snapGRP\['rotateZ_range'].setFlag(0x00000002)\n    snapGRP.addKnob(nuke.Array_Knob('rotateZ_seed', 'seed'))\n    snapGRP\['rotateZ_seed'].clearFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Array_Knob('scaleX_range', 'scale X range'))\n    snapGRP\['scaleX_range'].setFlag(0x00000002)\n    snapGRP.addKnob(nuke.Array_Knob('scaleX_seed', 'seed'))\n    snapGRP\['scaleX_seed'].clearFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Array_Knob('scaleY_range', 'scale Y range'))\n    snapGRP\['scaleY_range'].setFlag(0x00000002)\n    snapGRP.addKnob(nuke.Array_Knob('scaleY_seed', 'seed'))\n    snapGRP\['scaleY_seed'].clearFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Array_Knob('scaleZ_range', 'scale Z range'))\n    snapGRP\['scaleZ_range'].setFlag(0x00000002)\n    snapGRP.addKnob(nuke.Array_Knob('scaleZ_seed', 'seed'))\n    snapGRP\['scaleZ_seed'].clearFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Array_Knob('uniform_scale_range', 'uniform scale range'))\n    snapGRP\['uniform_scale_range'].setFlag(0x00000002)\n    snapGRP.addKnob(nuke.Array_Knob('uniform_scale_seed', 'seed'))\n    snapGRP\['uniform_scale_seed'].clearFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Tab_Knob('tab_misc', 'Instances'))\n\n    snapGRP.addKnob(nuke.Text_Knob('title_axis', '<b>DISPLAY AXIS</b>'))\n    snapGRP.addKnob(nuke.Boolean_Knob('display_axis', 'display instance axis'))\n    snapGRP\['display_axis'].setFlag(nuke.STARTLINE)\n    snapGRP.addKnob(nuke.Link_Knob('display_color', 'color'))\n    snapGRP\['display_color'].setLink('menu01.display_color')\n    snapGRP\['display_color'].clearFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Array_Knob('display_size', 'display size'))\n    snapGRP\['display_size'].setFlag(0x00000002)\n    snapGRP\['display_size'].setFlag(nuke.STARTLINE)\n    snapGRP\['display_size'].setValue(1)\n    snapGRP\['display_size'].setVisible(False)\n\n    snapGRP.addKnob(nuke.PyScript_Knob('invert_selection', 'invert selection',\n                                       \"for node in nuke.allNodes(\\'Axis\\') :\\n\\tif node.name()\[:3] == \\'ax_\\' :\\n\\t\\tnode\[\\'selected\\'].setValue( not node\[\\'selected\\'].value() )\"))\n    snapGRP\['invert_selection'].setFlag(nuke.STARTLINE)\n    snapGRP.addKnob(nuke.PyScript_Knob('deselect_all', 'de-select all',\n                                       'for node in nuke.allNodes() :\\n\\tnode.setSelected( False )'))\n\n    snapGRP.addKnob(nuke.Text_Knob('spacer4', '', '<br>'))\n\n    snapGRP.addKnob(nuke.Text_Knob('title_tools', '<b>ADJUST INSTANCES</b>'))\n\n    if _thisG\['snap_type'].getValue() and _thisG\['rgb_color'].getValue():\n        snapGRP.addKnob(nuke.Boolean_Knob('exColor', 'color'))\n        snapGRP\['exColor'].setFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.PyScript_Knob('extract_ins', 'extract instance', goStore\['cpCode02'].value()))\n    snapGRP.addKnob(nuke.Boolean_Knob('exTranslate', 'translate'))\n    snapGRP\['exTranslate'].setValue(True)\n    snapGRP.addKnob(nuke.Boolean_Knob('exRotate', 'rotate'))\n    snapGRP\['exRotate'].setValue(True)\n    snapGRP.addKnob(nuke.Boolean_Knob('exScale', 'scale'))\n    snapGRP\['exScale'].setValue(True)\n\n    snapGRP.addKnob(nuke.Text_Knob('spacer5', '', '<br>'))\n\n    # IE Add user input image control\n    snapGRP.addKnob(nuke.PyScript_Knob('user_set_input', 'set input', goStore\['cpCode04'].value()))\n    snapGRP\['user_set_input'].setFlag(nuke.STARTLINE)\n    snapGRP.addKnob(nuke.Enumeration_Knob(\"user_layer_list\", \" layer\", \[]))\n    snapGRP\['user_layer_list'].clearFlag(nuke.STARTLINE)\n    snapGRP.addKnob(nuke.Int_Knob(\"user_input_frame\", \" input frame\"))\n    snapGRP\['user_input_frame'].clearFlag(nuke.STARTLINE)\n    snapGRP\['user_input_frame'].setValue(int(texRNG\[0]))\n    # adjust label based on input type\n    if snapGRP.knob('input_type').getValue():\n        snapGRP.knob('user_input_frame').setLabel(' frame offset')\n    else:\n        snapGRP.knob('user_input_frame').setLabel(' turntable frame')\n\n\n    snapGRP.addKnob(nuke.Text_Knob('spacer6', '', '<br>'))\n\n    snapGRP.addKnob(nuke.PyScript_Knob('remove_ins', 'remove instance', goStore\['cpCode03'].value()))\n    snapGRP\['remove_ins'].setFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Text_Knob('spacer7', '', '<br>'))\n\n    snapGRP.addKnob(nuke.PyScript_Knob('adjustable_rotation_scale', 'manual rotation/scale', goStore\['cpCode08'].value()))\n    snapGRP\['adjustable_rotation_scale'].setTooltip(\"Removes expression from Axis rotation and scale, making it user adjustable in the viewport or properties panel\")\n    snapGRP\['adjustable_rotation_scale'].setFlag(nuke.STARTLINE)\n\n    snapGRP.addKnob(nuke.Tab_Knob('tab_info', 'Info', ))\n    snapGRP.addKnob(nuke.Text_Knob('info_snap', '<font color=cyan>snap type :</font>', _thisG\['snap_type'].value()))\n    snapGRP.addKnob(\n        nuke.Text_Knob('info_rot', '<font color=cyan>rotation type :</font>', _thisG\['rotation_type'].value()))\n    snapGRP.addKnob(nuke.Text_Knob('info_var', '<font color=cyan>input type :</font>', _thisG\['var_type'].value()))\n    if _thisG\['snap_type'].getValue() and _thisG\['rgb_color'].getValue():\n        snapGRP.addKnob(nuke.Text_Knob('info_tex', '<font color=cyan>texture :</font>', 'sample RGB color'))\n    else:\n        snapGRP.addKnob(nuke.Text_Knob('info_tex', '<font color=cyan>texture :</font>', 'instance geo texture'))\n    snapGRP.addKnob(nuke.Text_Knob('info_inst', '<font color=cyan>total instance :</font>', ''))\n\n    # add version that was used to create this note for debugging purposes\n    snapGRP.addKnob(nuke.Text_Knob('version_info', '<font color=cyan>version :</font>', '\{\} (date modified: \{\})'.format(_thisG\['ie_version'].value(), _thisG\['ie_date_modified'].value())))\n    # add documentation link\n    snapGRP.addKnob(nuke.Text_Knob('documentation_info', '<font color=cyan>documentation :</font>',\n                                   \"<a href ='http://docsie/index.php/MScatterGeo'><font color='orange'>Docsie</font ></a>\"))\n\n\n    snapGRP\['onCreate'].setValue(\n        \"thisGRP = nuke.thisGroup()\\nknobs = \[\\'rotateX_range\\',\\'rotateY_range\\',\\'rotateZ_range\\',\\'scaleX_range\\',\\'scaleY_range\\',\\'scaleZ_range\\',\\'uniform_scale_range\\',\\'display_size\\']\\nfor knob in knobs :\\n\\tthisGRP\[knob].setFlag(0x00000002)\")\n\n    ### IE ADD KNOB FOR STORING DATA\n    snapGRP.addKnob(nuke.Multiline_Eval_String_Knob('pts_pos', '', ''))\n\n    ### Set up callback function to adjust UI and for updating pts positions\n    snapGRP\['knobChanged'].setValue(goStore\['cpCode05'].value())\n\n    return snapGRP\n\ndef create_vegetation_loader(_name, _thisG):\n    availableName = findAvailableName(_name)\n    newName = _name + '_' + str(availableName)\n\n    xspace = int(nuke.toNode('preferences')\['GridWidth'].getValue())\n    yspace = int(nuke.toNode('preferences')\['GridHeight'].getValue())\n\n    random.seed(int(time.time()))\n\n    veg_loader_GRP = nuke.nodes.Group(\n        name=newName,\n        tile_color=int(thisGRP\['tile_color'].getValue()),\n        xpos=thisGRP.xpos() + (xspace + random.randint(0, xspace)),\n        ypos=thisGRP.ypos() - (yspace*4)\n    )\n\n    veg_loader_GRP.addKnob(nuke.Tab_Knob('tab_vegetation', 'Vegetation'))\n    # Active Input Checkbox and Indicator\n    veg_loader_GRP.addKnob(nuke.Boolean_Knob('active_input_updates', '<font color=green>&nbsp;<b>Input Updates Active'))\n    veg_loader_GRP\['active_input_updates'].setValue(1)\n    veg_loader_GRP.knob('label').setValue('<font color=green>UPDATE ACTIVE')\n    # Dropdown for choosing automatic layer naming convention\n    veg_loader_GRP.addKnob(nuke.Enumeration_Knob(\"layer_naming_convention\", \"Layer Naming Convention\",\n                                                 \[\"Input Node Name\", \"Render Pass Loader Name\",\n                                                  \"Metadata Vegetation Layer\"]))\n    veg_loader_GRP\['layer_naming_convention'].setValue(1)\n    # Add Button for MetadataNode Creation\n    veg_loader_GRP.addKnob(nuke.PyScript_Knob('create_metadata_layer_node', 'create Metadata-Layer node',\n                                              goStore\['cpCode09'].value()))\n    veg_loader_GRP\['create_metadata_layer_node'].setVisible(False)\n\n    veg_loader_GRP.addKnob(nuke.Int_Knob('input_naming_pos', 'Input Name Position'))\n    veg_loader_GRP.addKnob(nuke.Text_Knob('spacer1', '', '<br>'))\n    veg_loader_GRP.addKnob(nuke.Enumeration_Knob(\"input_layer_list\", \"Vegetation Layers\", \[]))\n    veg_loader_GRP.addKnob(nuke.PyScript_Knob('update_scatter_grp', 'update Scatter Grp', goStore\['cpCode07'].value()))\n\n    veg_loader_GRP.addKnob(nuke.Text_Knob('spacer2', '', '<br>'))\n    veg_loader_GRP.addKnob(nuke.Text_Knob('crypto_text', 'ID Mattes', ''))\n    veg_loader_GRP.addKnob(nuke.PyScript_Knob('create_encryptomatte_grp', 'create Vegetation Layer Encryptomatte Grp', goStore\['cpCode11'].value()))\n\n    # add version that was used to create this note for debugging purposes\n    veg_loader_GRP.addKnob(nuke.Tab_Knob('tab_info', 'Info'))\n    veg_loader_GRP.addKnob(nuke.Text_Knob('version_info', '<font color=cyan>version :</font>',\n                                   '\{\} (date modified: \{\})'.format(_thisG\['ie_version'].value(), _thisG\['ie_date_modified'].value())))\n    # add documentation link\n    veg_loader_GRP.addKnob(nuke.Text_Knob('documentation_info', '<font color=cyan>documentation :</font>',\n                                          \"<a href ='http://docsie/index.php/MScatterGeo'><font color='orange'>Docsie</font ></a>\"))\n\n\n    with veg_loader_GRP:\n        # create output node\n        out_node = nuke.nodes.Output()\n\n        # create merge node with correct settings\n        merge_node = nuke.nodes.Merge2()\n        merge_node\[\"name\"].setValue(\"Vegetation_Layer_Merge\")\n        merge_node\[\"Achannels\"].setValue(\"none\")\n        merge_node\[\"Bchannels\"].setValue(\"none\")\n        merge_node\[\"output\"].setValue(\"none\")\n        merge_node\[\"also_merge\"].setValue(\"all\")\n        out_node.setInput(0, merge_node)\n\n        # create first input (not connected to anything)\n        in1_node = nuke.nodes.Input()\n\n    # set up callback function with veg loader input logic\n    veg_loader_GRP\['knobChanged'].setValue(goStore\['cpCode06'].value())\n\n    return veg_loader_GRP\n\ndef selGons(_ptsID, _mainGeo):\n    ##### get quads prim group\n    prim = geoPrims(_mainGeo)\n\n    selVtxIDOnly = \[int(i\[2:]) for i in _ptsID]\n\n    gonsID = \[]\n    for ptsGRP in prim:\n        temp = 0\n        for i in ptsGRP:\n            temp += selVtxIDOnly.count(i)\n        if temp != 0:\n            gonsID.append('0_' + '_'.join(\[str(j) for j in ptsGRP]))\n\n    return gonsID\n\ndef sfvConvert(_svlist):\n    primNameList = \[]\n    for grp in _svlist:\n        temp = \[]\n        for vtx in range(len(grp)):\n            temp.append(str(grp\[vtx]))\n        primNameList.append('0_' + '_'.join(temp))\n\n    return primNameList\n\ndef genFaceNor(_thisG, _mainstream, _mainGeo, _svlist, _selType, _fRNG=\[0, 0]):\n    pyg = nuke.toNode('PythonGeo')\n\n    ##### get selected prims\n    if _selType == 'face':\n        primID = sfvConvert(_svlist)\n    elif _selType == 'vertex':\n        primID = _svlist\n    elif _selType == 'vertexFaces':\n        primID = selGons(_svlist, _mainGeo)\n\n    ##### find available name and create global group\n    with getLevel():\n        snapGRP = makePackage('mSnap', _thisG)\n\n    ##### prep\n    with snapGRP:\n        grpBasic(primID, _thisG)\n\n        ##### snap faces\n        _mainstream.reverse()\n\n        if _thisG\['with_animation'].value():\n            nuke.toNode('store')\['aniRNG'].setValue('-'.join(\[str(i) for i in _fRNG]))\n            nuke.thisGroup()\['info_aniRange'].setValue('-'.join(\[str(i) for i in _fRNG]))\n\n            ct_hack = nuke.nodes.CurveTool()\n            progBar = nuke.ProgressTask('Sampling vertices')\n            jobCount = 0\n            jobTotal = (_fRNG\[1] + 1) - _fRNG\[0]\n            for ctime in range(_fRNG\[0], _fRNG\[1] + 1, 1):\n                nuke.execute(ct_hack, ctime, ctime)\n                ### progress bar\n                jobCount += 1\n                progShow = int(jobCount / jobTotal * 100)\n                if progBar.isCancelled():\n                    break;\n                progBar.setProgress(progShow)\n                #################\n\n                gData = geoData(pyg, 0)  ##### get geo data\n                for node in nuke.allNodes('Axis'):\n                    if node.name() != 'worldTransform':\n                        kname = node.name().split('_')\[2:]\n\n                        if ctime == _fRNG\[0]:\n                            node\['translate'].setAnimated()\n                            node\['orig_rot'].setAnimated()\n\n                        if _selType == 'face' or _selType == 'vertexFaces':\n                            vec1 = nuke.math.Vector3(\n                                gData\['0_' + str(kname\[0])]\[0]\[0],\n                                gData\['0_' + str(kname\[0])]\[0]\[1],\n                                gData\['0_' + str(kname\[0])]\[0]\[2]\n                            )\n                            vec2 = nuke.math.Vector3(\n                                gData\['0_' + str(kname\[1])]\[0]\[0],\n                                gData\['0_' + str(kname\[1])]\[0]\[1],\n                                gData\['0_' + str(kname\[1])]\[0]\[2]\n                            )\n                            vec3 = nuke.math.Vector3(\n                                gData\['0_' + str(kname\[2])]\[0]\[0],\n                                gData\['0_' + str(kname\[2])]\[0]\[1],\n                                gData\['0_' + str(kname\[2])]\[0]\[2]\n                            )\n                            for i in range(3):\n                                node\['translate'].setValueAt(\n                                    nukescripts.snap3d.calcAveragePosition(convertIter(gData, kname))\[i], ctime, i)\n                                node\['orig_rot'].setValueAt(\n                                    math.degrees(nukescripts.snap3d.planeRotation((vec1, vec2, vec3), norm=None)\[i]),\n                                    ctime, i)\n\n                            del vec1, vec2, vec3\n                        elif _selType == 'vertex':\n                            for i in range(3):\n                                node\['translate'].setValueAt(gData\['0_' + kname\[0]]\[0]\[i], ctime, i)\n                                node\['orig_rot'].setValueAt(norToRot3D(gData, '0_' + kname\[0])\[i], ctime, i)\n\n                    if node.name() == 'worldTransform':\n                        wTrans = unify(_mainstream, ctime)  ##### get world transformation\n                        node\['useMatrix'].setValue(True)\n                        node\['matrix'].setAnimated()\n                        for mtx in range(16):\n                            node\['matrix'].setValueAt(wTrans\[mtx], ctime, mtx)\n\n            nuke.delete(ct_hack)\n            del progBar, jobCount, jobTotal, progShow\n\n        else:\n            gData = geoData(pyg, 0)  ##### get geo data\n            for node in nuke.allNodes('Axis'):\n                if node.name() != 'worldTransform':\n                    kname = node.name().split('_')\[2:]\n\n                    if _selType == 'face' or _selType == 'vertexFaces':\n                        vec1 = nuke.math.Vector3(\n                            gData\['0_' + str(kname\[0])]\[0]\[0],\n                            gData\['0_' + str(kname\[0])]\[0]\[1],\n                            gData\['0_' + str(kname\[0])]\[0]\[2]\n                        )\n                        vec2 = nuke.math.Vector3(\n                            gData\['0_' + str(kname\[1])]\[0]\[0],\n                            gData\['0_' + str(kname\[1])]\[0]\[1],\n                            gData\['0_' + str(kname\[1])]\[0]\[2]\n                        )\n                        vec3 = nuke.math.Vector3(\n                            gData\['0_' + str(kname\[2])]\[0]\[0],\n                            gData\['0_' + str(kname\[2])]\[0]\[1],\n                            gData\['0_' + str(kname\[2])]\[0]\[2]\n                        )\n                        for i in range(3):\n                            node\['translate'].setValue(\n                                nukescripts.snap3d.calcAveragePosition(convertIter(gData, kname))\[i], i)\n                            node\['orig_rot'].setValue(\n                                math.degrees(nukescripts.snap3d.planeRotation((vec1, vec2, vec3), norm=None)\[i]), i)\n                    elif _selType == 'vertex':\n                        node\['translate'].setValue(gData\['0_' + kname\[0]]\[0])\n                        node\['orig_rot'].setValue(norToRot3D(gData, '0_' + kname\[0]))\n\n                if node.name() == 'worldTransform':\n                    wTrans = unify(_mainstream, nuke.frame())  ##### get world transformation\n                    node\['useMatrix'].setValue(True)\n                    for mtx in range(16):\n                        node\['matrix'].setValue(wTrans\[mtx], mtx)\n\n    del primID, gData, kname, snapGRP, wTrans, _thisG, _mainstream, _mainGeo, _svlist, _selType, _fRNG\n\ndef genSelVtx(_thisG, _mainstream, _svlist, _selType, _fRNG=\[0, 0]):\n    pyg = nuke.toNode('PythonGeo')\n\n    ##### find available name and create global group\n    with getLevel():\n        snapGRP = makePackage('mSnap', _thisG)\n\n    ##### prep\n    with snapGRP:\n        if _selType == 'face':\n            grpBasic(sfvConvert(_svlist), _thisG)\n        elif _selType == 'vertex':\n            grpBasic(_svlist, _thisG)\n\n        ##### snap points\n        _mainstream.reverse()\n\n        if _thisG\['with_animation'].value():\n            nuke.toNode('store')\['aniRNG'].setValue('-'.join(\[str(i) for i in _fRNG]))\n            nuke.thisGroup()\['info_aniRange'].setValue('-'.join(\[str(i) for i in _fRNG]))\n\n            ct_hack = nuke.nodes.CurveTool()\n            progBar = nuke.ProgressTask('Sampling vertices')\n            jobCount = 0\n            jobTotal = (_fRNG\[1] + 1) - _fRNG\[0]\n\n            for ctime in range(_fRNG\[0], _fRNG\[1] + 1):\n                nuke.execute(ct_hack, ctime, ctime)\n                ### progress bar\n                jobCount += 1\n                progShow = int(jobCount / jobTotal * 100)\n                if progBar.isCancelled():\n                    break;\n                progBar.setProgress(progShow)\n                #################\n\n                gData = geoData(pyg, 0)  ##### get geo data\n                for node in nuke.allNodes('Axis'):\n                    if node.name() != 'worldTransform':\n                        kname = node.name().split('_')\[2:]\n\n                        if _selType == 'face':\n                            if ctime == _fRNG\[0]:\n                                node\['translate'].setAnimated()\n                            for i in range(3):\n                                node\['translate'].setValueAt(\n                                    nukescripts.snap3d.calcAveragePosition(convertIter(gData, kname))\[i], ctime, i)\n                        elif _selType == 'vertex':\n                            if ctime == _fRNG\[0]:\n                                node\['translate'].setAnimated()\n                            for i in range(3):\n                                node\['translate'].setValueAt(gData\['0_' + kname\[0]]\[0]\[i], ctime, i)\n\n                    if node.name() == 'worldTransform':\n                        wTrans = unify(_mainstream, ctime)  ##### get world transformation\n                        node\['useMatrix'].setValue(True)\n                        node\['matrix'].setAnimated()\n                        for mtx in range(16):\n                            node\['matrix'].setValueAt(wTrans\[mtx], ctime, mtx)\n\n            nuke.delete(ct_hack)\n            del progBar, jobCount, jobTotal, progShow\n\n        else:\n            gData = geoData(pyg, 0)  ##### get geo data\n            for node in nuke.allNodes('Axis'):\n                if node.name() != 'worldTransform':\n                    kname = node.name().split('_')\[2:]\n\n                    if _selType == 'face':\n                        for i in range(3):\n                            node\['translate'].setValue(\n                                nukescripts.snap3d.calcAveragePosition(convertIter(gData, kname))\[i], i)\n                    elif _selType == 'vertex':\n                        node\['translate'].setValue(gData\['0_' + kname\[0]]\[0])\n\n                if node.name() == 'worldTransform':\n                    wTrans = unify(_mainstream, nuke.frame())  ##### get world transformation\n                    node\['useMatrix'].setValue(True)\n                    for mtx in range(16):\n                        node\['matrix'].setValue(wTrans\[mtx], mtx)\n\n    del gData, kname, snapGRP, wTrans, _thisG, _mainstream, _svlist, _selType, _fRNG\n\ndef convertIter(_gd, _prim):\n    loopNum = len(_prim)\n    for i in range(loopNum):\n        tPos = nuke.math.Vector4(\n            _gd\['0_' + str(_prim\[i])]\[0]\[0],\n            _gd\['0_' + str(_prim\[i])]\[0]\[1],\n            _gd\['0_' + str(_prim\[i])]\[0]\[2],\n            1.0\n        )\n        yield nukescripts.snap3d.VertexInfo(0, 0, 1, nuke.math.Vector3(tPos.x, tPos.y, tPos.z))\n\ndef grpBasic(_data, _thisG):\n    # create INPUTS\n    geoInput = nuke.nodes.Input(name='geo')\n    # IE add seperate texture input\n    texInput = nuke.nodes.Input(name='tex')\n\n    if _thisG\['rotation_type'].getValue() == 0:\n        camInput = nuke.nodes.Input(name='axis_cam')\n\n    geoDot = nuke.nodes.Dot()\n    geoDot.setInput(0, geoInput)\n\n    texDot = nuke.nodes.Dot()\n    texDot.setInput(0, texInput)\n\n    sceneAll = nuke.nodes.Scene(name='MassiveScene')\n    nuke.nodes.Output(inputs=\[sceneAll])\n\n    menu01 = nuke.nodes.NoOp(name='menu01')\n    menu01.addKnob(nuke.ColorChip_Knob('display_color', 'color'))\n    menu01\['knobChanged'].setValue(goStore\['cpCode01'].value())\n    glColor = int('%02x%02x%02x%02x' % (1 * 255, 0 * 255, 0 * 255, 1), 16)\n    menu01\['display_color'].setValue(glColor)\n\n    ##### copy function\n    copyStore = nuke.nodes.NoOp(name='store')\n    copyStore.addKnob(nuke.PyScript_Knob('fn', 'fn', goStore\['fn02'].value()))\n    copyStore.addKnob(nuke.Multiline_Eval_String_Knob('filterNonReverse', 'filterNonReverse', goStore\['filterNonReverse'].value()))\n    copyStore\['filterNonReverse'].setEnabled(False)\n    copyStore.addKnob(nuke.Multiline_Eval_String_Knob('filter3DNodes', 'filter3DNodes', goStore\['filter3DNodes'].value()))\n    copyStore\['filter3DNodes'].setEnabled(False)\n    if _thisG\['with_animation'].value():\n        copyStore.addKnob(nuke.EvalString_Knob('aniRNG', 'aniRNG', '1001-1100'))\n\n    ##### apply geo's transformation\n    worldTrans = nuke.nodes.Axis(\n        name='worldTransform',\n        display='off',\n        selectable=0\n    )\n\n    ##### RGB color setup\n    if _thisG\['snap_type'].getValue() and _thisG\['rgb_color'].getValue():\n        colorRes = nuke.nodes.Reformat(\n            type=1,\n            box_fixed=True,\n            box_width=32, box_height=32\n        )\n        colorBasic = nuke.nodes.Expression(\n            channel0='red', channel1='green', channel2='blue', channel3='alpha',\n            expr0='1', expr1='1', expr2='1', expr3='1',\n            inputs=\[colorRes]\n        )\n\n    ##### mass generate nodes\n    for key in range(0, len(_data)):\n\n        # IE add additional apply material node for layer work\n        mat_node = nuke.nodes.ApplyMaterial()\n        mat_node.setInput(0, geoDot)\n\n        randTexEX = 'trunc( ( random(tex_seed, \{0\}) * (range_end-range_start) ) + range_start )'.format(key)\n        randOffsetEX = 'trunc( ( random(tex_seed, \{0\}) * (offset_end) ) )'.format(key)\n\n        # Always Create both FrameHold and TimeOffset and disable according to mode\n        framehold_node = nuke.nodes.FrameHold()\n        framehold_node\['first_frame'].setExpression(randTexEX)\n        timeoffset_node = nuke.nodes.TimeOffset()\n        timeoffset_node\['time_offset'].setExpression(randOffsetEX)\n        framehold_node.setInput(0, mat_node)\n        timeoffset_node.setInput(0, framehold_node)\n        framehold_node\['disable'].setExpression('parent.input_type == 0.0 ? False : True')\n        timeoffset_node\['disable'].setExpression('parent.input_type == 1.0 ? False : True')\n\n        input_switch_node = nuke.nodes.Switch()\n        input_switch_node\[\"which\"].setExpression(\"trunc(random(tex_seed,\{0\})*number_of_layers+1)\".format(key))\n        input_switch_node.setInput(0, texDot)\n        mat_node.setInput(1, input_switch_node)\n\n        scatterAX = nuke.nodes.Axis(\n            name='ax_' + str(key),\n            gl_color=glColor,\n            inputs=\[worldTrans]\n        )\n\n        ##### axis setting\n        scatterAX\['display'].setExpression('parent.display_axis')\n        scatterAX\['scaling'].setExpression(\n            '1+((random( \{2\}, \{0\} ) -0.5) * parent.\{1\} )'.format(key, 'scaleX_range', 'scaleX_seed'), 0)\n        scatterAX\['scaling'].setExpression(\n            '1+((random( \{2\}, \{0\} ) -0.5) * parent.\{1\} )'.format(key, 'scaleY_range', 'scaleY_seed'), 1)\n        scatterAX\['scaling'].setExpression(\n            '1+((random( \{2\}, \{0\} ) -0.5) * parent.\{1\} )'.format(key, 'scaleZ_range', 'scaleZ_seed'), 2)\n        scatterAX\['uniform_scale'].setExpression(\n            '1+((random( \{2\}, \{0\} ) -0.5) * parent.\{1\} )'.format(key, 'uniform_scale_range', 'uniform_scale_seed', 'display_size'))\n\n        scatterAX.addKnob(nuke.Array_Knob('axid', 'axid'))\n        scatterAX\['axid'].setValue(key)\n        scatterAX.addKnob(nuke.XYZ_Knob('orig_rot', 'orig_rot'))\n        scatterAX\['rotate'].setExpression(\n            '(random( \{2\}, \{0\} ) -0.5) * 360 * \{1\} + \{3\}'.format('axid', 'rotateX_range', 'rotateX_seed', 'orig_rot'), 0)\n        scatterAX\['rotate'].setExpression(\n            '(random( \{2\}, \{0\} ) -0.5) * 360 * \{1\} + \{3\}'.format('axid', 'rotateY_range', 'rotateY_seed', 'orig_rot'), 1)\n        scatterAX\['rotate'].setExpression(\n            '(random( \{2\}, \{0\} ) -0.5) * 360 * \{1\} + \{3\}'.format('axid', 'rotateZ_range', 'rotateZ_seed', 'orig_rot'), 2)\n\n        genTransGeo = nuke.nodes.TransformGeo()\n        # genTransGeo\['uniform_scale'].setExpression('1 / \{0\}'.format('display_size')) # might want to include this functionality again in future\n        genTransGeo.setInput(0, timeoffset_node)\n        genTransGeo.setInput(1, scatterAX)\n\n        if _thisG\['rotation_type'].getValue() == 0:\n            genTransGeo.setInput(2, camInput)\n\n        ##### RGB color setup\n        if _thisG\['snap_type'].getValue() and _thisG\['rgb_color'].getValue():\n            appColor = nuke.nodes.Multiply(\n                name='cc_' + _data\[key],\n                inputs=\[colorBasic]\n            )\n            appColor\['value'].setSingleValue(False)\n            appMat = nuke.nodes.ApplyMaterial(\n                inputs=\[genTransGeo, appColor]\n            )\n            sceneAll.setInput(key, appMat)\n        else:\n            sceneAll.setInput(key, genTransGeo)\n\n    nuke.thisGroup()\['info_inst'].setValue(str(len(_data)))\n\ndef selID():\n    chkid = \[]\n    selobj = \[]\n    selidx = \[]\n    selpos = \[]\n    rm = \[]\n    count = 0\n\n    for vtx in nukescripts.snap3d.selectedVertexInfos():\n        temp = str(vtx.objnum) + '_' + str(vtx.index)\n        if not chkid.count(temp):\n            chkid.append(temp)\n\n            if selidx.count(vtx.index):\n                place = selidx.index(vtx.index)\n                if selpos\[place] == vtx.position:\n                    if selobj\[place] < vtx.objnum:\n                        rm.append(place)\n                    else:\n                        rm.append(count)\n\n            selobj.append(vtx.objnum)\n            selidx.append(vtx.index)\n            selpos.append(vtx.position)\n            count += 1\n\n    selPts = \[]\n\n    for i in range(len(selpos)):\n        if i not in rm:\n            selPts.append(str(selobj\[i]) + '_' + str(selidx\[i]))\n\n    del chkid, selobj, selidx, selpos, rm, count\n\n    return selPts\n\ndef randSelID(_slist, _thisG):\n    randMax = round(max(0, min(1, _thisG\['random_percentage'].getValue() / 100)) * len(_slist))\n    randID = \[]\n    random.seed(int(_thisG\['random_seed'].getValue()))\n    while len(randID) < randMax:\n        choosenOne = _slist\[random.randint(0, len(_slist) - 1)]\n        if not choosenOne in randID:\n            randID.append(choosenOne)\n\n    return randID\n\ndef primaryGeo(_mainstream, _filterPrimitives):\n    for sub in _mainstream:\n        for node in sub:\n            if node.Class() in _filterPrimitives:\n                return node\n\ndef geoPrims(_mainGeo):\n    gonType = len(nuke.toNode('PythonGeo')\['geo'].getGeometry()\[0].primitives())\n    if gonType > 1:\n        ##### tris\n        gPrims = list(nuke.toNode('PythonGeo')\['geo'].getGeometry()\[0].primitives())\n    else:\n        if _mainGeo.Class() == 'ReadGeo' or _mainGeo.Class() == 'ReadGeo2':\n            ##### custom geo\n            gPrims = \[]\n            prims = nuke.toNode('PythonGeo')\['geo'].getGeometry()\[0].primitives()\n            for prim in grouper(4, prims\[0]):\n                gPrims.append(prim)\n        else:\n            ##### quads\n            gPrims = \[]\n            for prim in _mainGeo\['geo_select'].getGeometry().__getitem__(0).primitives():\n                for face in range(0, prim.faces()):\n                    gPrims.append(prim.faceVertices(face))\n\n    return gPrims\n\ndef norToRot3D(_gData, _vid):\n    ##### rotate x\n    rx = -math.asin(_gData\[_vid]\[1]\[1])\n\n    ##### rotate y\n    try:\n        if _gData\[_vid]\[1]\[2] < 0 and _gData\[_vid]\[1]\[0] < 0:\n            ry = -(math.pi + math.asin(_gData\[_vid]\[1]\[0] / math.cos(-math.asin(_gData\[_vid]\[1]\[1]))))\n        elif _gData\[_vid]\[1]\[2] < 0 and _gData\[_vid]\[1]\[0] > 0:\n            ry = math.pi - math.asin(_gData\[_vid]\[1]\[0] / math.cos(-math.asin(_gData\[_vid]\[1]\[1])))\n        else:\n            ry = math.asin(_gData\[_vid]\[1]\[0] / math.cos(-math.asin(_gData\[_vid]\[1]\[1])))\n    except ValueError:\n        if _gData\[_vid]\[1]\[0] > 0:\n            ry = 90\n        else:\n            ry = -90\n\n    del _gData, _vid\n\n    rot3 = \[math.degrees(rx) % 360 + 90, math.degrees(ry) % 360, 0]\n    return rot3\n\ndef norToRotMap(_nor):\n    ##### rotate x\n    rx = -math.asin(_nor\[1])\n\n    ##### rotate y\n    try:\n        if _nor\[2] < 0 and _nor\[0] < 0:\n            ry = -(math.pi + math.asin(_nor\[0] / math.cos(-math.asin(_nor\[1]))))\n        elif _nor\[2] < 0 and _nor\[0] > 0:\n            ry = math.pi - math.asin(_nor\[0] / math.cos(-math.asin(_nor\[1])))\n        else:\n            ry = math.asin(_nor\[0] / math.cos(-math.asin(_nor\[1])))\n    except ValueError:\n        if _nor\[0] > 0:\n            ry = 90\n        else:\n            ry = -90\n\n    del _nor\n\n    rot3 = \[math.degrees(rx) % 360 + 90, math.degrees(ry) % 360, 0]\n    return rot3\n\ndef scanTile(_thisG, _startNode, _ctNode, _res):\n    ##### setup curveTool node\n    scanCropSize = 32\n    _ctNode\['operation'].setValue('Auto Crop')\n    _ctNode\['channels'].setValue('alpha')\n    _ctNode\['ROI'].setValue(\[0, 0, scanCropSize, scanCropSize])\n\n    sNodes = \[]\n    uvShift = nuke.nodes.Transform(inputs=\[_startNode])\n    crop32 = nuke.nodes.Crop(inputs=\[uvShift])\n    crop32\['box'].setValue(\[0, 0, _res, _res])\n    scan32 = nuke.nodes.Reformat(\n        type=1, box_fixed=True, box_width=scanCropSize, box_height=scanCropSize,\n        inputs=\[crop32]\n    )\n\n    if _thisG\['uv_type'].getValue() == 0:\n        _ctNode.setInput(0, scan32)\n        nuke.execute(_ctNode, nuke.frame(), nuke.frame())\n        cropResult = _ctNode\['autocropdata'].getValue()\n        if (cropResult\[2] - cropResult\[0]) > 0 or (cropResult\[3] - cropResult\[1]) > 0:\n            uvCrop = nuke.nodes.Crop(\n                name='crop_00',\n                reformat=True,\n                inputs=\[uvShift]\n            )\n            for i in range(4):\n                uvCrop\['box'].setValue(cropResult\[i] * _res / scanCropSize, i)\n            sNodes.append(uvCrop)\n        else:\n            nuke.delete(uvShift)\n    else:\n        for y in range(10):\n            for x in range(10):\n                uvShift\['translate'].setValue(-(_res * x), 0)\n                uvShift\['translate'].setValue(-(_res * y), 1)\n                # uvShift\['label'].setValue( 'tile : \{0\} | \{1\}' .format( str(x), str(y) ) )\n\n                _ctNode.setInput(0, scan32)\n                nuke.execute(_ctNode, nuke.frame(), nuke.frame())\n                cropResult = _ctNode\['autocropdata'].getValue()\n\n                if (cropResult\[2] - cropResult\[0]) > 0 or (cropResult\[3] - cropResult\[1]) > 0:\n                    nuke.delete(crop32)\n                    nuke.delete(scan32)\n                    uvCrop = nuke.nodes.Crop(\n                        name='crop_\{0\}\{1\}'.format(str(y), str(x)),\n                        reformat=True,\n                        inputs=\[uvShift]\n                    )\n                    for i in range(4):\n                        uvCrop\['box'].setValue(cropResult\[i] * _res / scanCropSize, i)\n                    sNodes.append(uvCrop)\n                    uvShift = nuke.nodes.Transform(inputs=\[_startNode])\n                    crop32 = nuke.nodes.Crop(inputs=\[uvShift])\n                    crop32\['box'].setValue(\[0, 0, 512, 512])\n                    scan32 = nuke.nodes.Reformat(\n                        type=1, box_fixed=True, box_width=scanCropSize, box_height=scanCropSize,\n                        inputs=\[crop32]\n                    )\n                elif x == 9 and y == 9:\n                    nuke.delete(uvShift)\n\n    nuke.delete(crop32)\n    nuke.delete(scan32)\n    _ctNode\['autocropdata'].clearAnimated()\n    _ctNode.setInput(0, None)\n\n    return sNodes\n\ndef rmNodes(_uvST):\n    followNodes = _uvST.dependent(forceEvaluate=False)\n    for node in followNodes:\n        check = 0\n        cNodes = \[node]\n        while check < 1:\n            if len(cNodes\[-1:]\[0].dependent(forceEvaluate=False)) != 0:\n                cNodes.append(cNodes\[-1:]\[0].dependent(forceEvaluate=False)\[0])\n            else:\n                check = 1\n        for rm in cNodes:\n            nuke.delete(rm)\n\ndef genDMap(_thisG, _svlist, _sNodes, _fRNG=\[0, 0]):\n    ##### find available name and create global groups\n    with getLevel():\n        vegGRP = create_vegetation_loader('VegetationLoader', _thisG)\n        snapGRP = makePackage('mSnap', _thisG)\n\n        # link the two layer lists\n        snapGRP\[\"linked_input_layer_list\"].setExpression('\{\}.input_layer_list'.format(vegGRP.name()), 0)\n        # connect tex to Vegetation Loader\n        snapGRP.setInput(1, vegGRP)\n\n    # IE ADD THE DATA\n    # add scatter variation point list\n    pos_variation_list = \[]\n    for variation in _svlist:\n        pos_list = calculate_pos(_thisG, _sNodes, variation)\n        pos_variation_list.append(pos_list)\n    snapGRP\[\"pts_pos\"].setValue(str(pos_variation_list))\n    snapGRP\[\"pts_pos\"].setVisible(False)\n\n    ##### prep\n    with snapGRP:\n        grpBasic(_svlist\[0], _thisG)\n\n        ##### RGB color - currently not used in our setup but kept in case we want this functionality\n        if _thisG\['rgb_color'].value():\n            for node in nuke.allNodes('Multiply'):\n                kname = node.name().split('_')\[1:]\n                for cropNode in _sNodes:\n                    if cropNode.name() == 'crop_\{0\}'.format(kname\[0]):\n                        rgb = \[cropNode.sample('red', int(kname\[1]), int(kname\[2])),\n                               cropNode.sample('green', int(kname\[1]), int(kname\[2])),\n                               cropNode.sample('blue', int(kname\[1]), int(kname\[2]))]\n                        for i in range(3):\n                            nuke.toNode('cc_\{0\}'.format('_'.join(kname)))\['value'].setValue(rgb\[i], i)\n\n        for node in nuke.allNodes('Axis'):\n            if node.name() != 'worldTransform':\n                update_axis_values()\n\ndef update_axis_values():\n    pts_pos_list = eval(nuke.thisNode()\[\"pts_pos\"].getText())\n    current_seed = int(nuke.thisNode()\[\"seed_controller\"].getValue())\n    for node in nuke.allNodes('Axis'):\n        if node.name() != 'worldTransform':\n            current_axid = int(node\[\"axid\"].getValue())\n            pos = \[pts_pos_list\[current_seed]\[current_axid]\[0],\n                   pts_pos_list\[current_seed]\[current_axid]\[1],\n                   pts_pos_list\[current_seed]\[current_axid]\[2]]\n            node\['translate'].setValue(pos)\n\ndef calculate_pos(_thisG, _sNodes, pts_list):\n    pos_list = \[]\n    for pt_string in pts_list:\n        pt = pt_string.split('_')\n        for cropNode in _sNodes:\n            if cropNode.name() == 'crop_\{0\}'.format(pt\[0]):\n                pos = (cropNode.sample('pos.red', int(pt\[1]), int(pt\[2])),\n                       cropNode.sample('pos.green', int(pt\[1]), int(pt\[2])),\n                       cropNode.sample('pos.blue', int(pt\[1]), int(pt\[2])))\n                pos_list.append(pos)\n    return pos_list\n\ndef calculate_rotation(_thisG, _sNodes, pts_list):\n    #TODO: need to properly implement this if needed\n\n    for cropNode in _sNodes:\n        if cropNode.name() == 'crop_\{0\}'.format(pts_list\[0]):\n            ##### snap rotation\n            if _thisG\['rotation_type'].getValue():\n                nor = \[cropNode.sample('nor.red', int(pts_list\[1]), int(pts_list\[2])),\n                       cropNode.sample('nor.green', int(pts_list\[1]), int(pts_list\[2])),\n                       cropNode.sample('nor.blue', int(pts_list\[1]), int(pts_list\[2]))]\n                for i in range(3):\n                    pass\n                    #node\['orig_rot'].setValue(norToRotMap(nor)\[i], i)\n\ndef samID(_thisG, _tileData, random_seed=None):\n    pos2D = \[]\n    if random_seed:\n        random.seed(int(random_seed))\n    else:\n        random.seed(int(_thisG\['dmap_seed'].getValue()))\n    for key, value in _tileData.items():\n        count = 0\n        subCount = 0\n        p2Data = \[]\n        while count < value\[1]:\n            samXY = \[random.randint(0, value\[0].width()), random.randint(0, value\[0].height())]\n            alpha = value\[0].sample('alpha', samXY\[0], samXY\[1])\n            pos = \[value\[0].sample('pos.red', samXY\[0], samXY\[1]), value\[0].sample('pos.green', samXY\[0], samXY\[1]),\n                   value\[0].sample('pos.blue', samXY\[0], samXY\[1])]\n            if alpha > 0 and samXY not in p2Data and pos != \[0, 0, 0]:\n                coRNG = int((1 - max(min(value\[0].sample('alpha', samXY\[0], samXY\[1]), 1.0), 0.01)) * 50)\n                xRNG = \[samXY\[0] - int(coRNG / 2) + i for i in range(int(coRNG / 2))]\n                yRNG = \[samXY\[1] - int(coRNG / 2) + i for i in range(int(coRNG / 2))]\n                if not len(list(set(\[i\[0] for i in p2Data]).intersection(xRNG))):\n                    if not len(list(set(\[i\[1] for i in p2Data]).intersection(yRNG))):\n                        p2Data.append(samXY)\n                        count += 1\n                    else:\n                        if subCount > _thisG\['fail_attempts'].getValue():\n                            count = value\[1]\n                        subCount += 1\n\n        p2Data = \[str(key.split('_')\[1]) + '_' + str(p\[0]) + '_' + str(p\[1]) for p in p2Data]\n        pos2D += p2Data\n\n    del p2Data, coRNG, xRNG, yRNG, _thisG, _tileData\n\n    return pos2D\n" +STARTLINE}
  addUserKnob {22 fn02 -STARTLINE T "import math\n\ndef getLevel():\n    ### level define ###\n    if len(nuke.thisNode().fullName().split('.')) == 1:\n        ggLevel = nuke.root()\n    else:\n        nodePath = nuke.thisNode().fullName().split('.')\n        nodePath.pop()\n        ggLevel = nuke.toNode('.'.join(nodePath))\n    return ggLevel\n\ndef upstreamNodes(_startNode, _filterClass):\n    mainStream = \[]\n    curNode = _startNode\n    while curNode:\n        if curNode.knob('matrix'):\n            if curNode.Class() in _filterClass:\n                subStream = \[curNode]\n\n                for x in range(1, curNode.inputs()):\n                    subNode = curNode.input(x)\n                    if subNode.knob('matrix'):\n                        subStream.append(subNode)\n\n                    while subNode:\n                        for y in range(0, subNode.inputs()):\n                            if subNode.input(y).knob('matrix'):\n                                subStream.append(subNode.input(y))\n                        subNode = subNode.input(0)\n\n                mainStream.append(subStream)\n        curNode = curNode.input(0)\n\n    del subStream, curNode, _startNode, _filterClass\n\n    return mainStream\n\ndef unify(_mainstream, _vtime):\n    # check input node type ##########################################\n    if _mainstream\[len(_mainstream) - 1]\[0] in filterCheck:\n        _mainstream.reverse()\n\n    outMTX = nuke.math.Matrix4()\n    for a in range(0, len(_mainstream)):\n        for b in range(0, len(_mainstream\[a])):\n\n            getMTX = nuke.math.Matrix4()\n            focusNode = _mainstream\[a]\[b]\n\n            for q in range(0, 16):\n                getMTX\[q] = focusNode.knob('matrix').getValueAt(_vtime)\[q]\n\n            if a != 0:\n                outMTX = outMTX * getMTX\n            else:\n                outMTX = getMTX\n\n    return outMTX\n\ndef autoBackdrop_mod(_name, _tileC):\n    selNodes = nuke.selectedNodes()\n\n    # Calculate bounds for the backdrop node.\n    bdX = min(\[node.xpos() for node in selNodes])\n    bdY = min(\[node.ypos() for node in selNodes])\n    bdW = max(\[node.xpos() + node.screenWidth() for node in selNodes]) - bdX\n    bdH = max(\[node.ypos() + node.screenHeight() for node in selNodes]) - bdY\n\n    # Expand the bounds to leave a little border. Elements are offsets for left, top, right and bottom edges respectively\n    left, top, right, bottom = (-10, -80, 10, 10)\n    bdX += left\n    bdY += top\n    bdW += (right - left)\n    bdH += (bottom - top)\n\n    n = nuke.nodes.BackdropNode(\n        label=_name,\n        xpos=bdX,\n        bdwidth=bdW,\n        ypos=bdY,\n        bdheight=bdH,\n        tile_color=_tileC,\n        note_font_size=42,\n    )\n\n    # revert to previous selection\n    n\['selected'].setValue(False)\n\n    return n\n\ndef mtx2value(_uMTX):\n    _uMTX.transpose()\n\n    mTranslate = nuke.math.Matrix4(_uMTX)\n    mTranslate.translationOnly()\n    translate = (mTranslate\[12], mTranslate\[13], mTranslate\[14])\n\n    mRotate = nuke.math.Matrix4(_uMTX)\n    mRotate.rotationOnly()\n    rotateRad = mRotate.rotationsZXY()\n    rotate = (math.degrees(rotateRad\[0]), math.degrees(rotateRad\[1]), math.degrees(rotateRad\[2]))\n\n    mScale = nuke.math.Matrix4(_uMTX)\n    mScale.scaleOnly()\n    scale = (mScale.xAxis().x, mScale.yAxis().y, mScale.zAxis().z)\n\n    return (translate, rotate, scale)\n\ndef find_topnode(node):\n    if node.input(0):\n        return find_topnode(node.input(0))\n    else:\n        return node\n"}
  addUserKnob {22 cpCode01 T "for node in nuke.allNodes() :\n    if node.name()\[0:3] == 'ax_' :\n        node\['gl_color'].setValue( int( nuke.thisGroup()\['display_color'].getValue() ) )" +STARTLINE}
  addUserKnob {22 cpCode02 -STARTLINE T "import math\n\nthisGRP = nuke.thisGroup()\n\ngoStore = nuke.toNode('store')\ngoStore\['fn'].execute()\n\nif thisGRP\['exTranslate'].value() or thisGRP\['exRotate'].value() or thisGRP\['exScale'].value() :\n\n\t##### get selected axis\n\tselAX = \[]\n\twith thisGRP :\n\t\tfor node in nuke.allNodes() :\n\t\t\tif node.name()\[0:3] == 'ax_' and node\['selected'].getValue() == 1 :\n\t\t\t\tselAX.append( node )\n\n\tif len(selAX) :\n\t\tspace = \[ int(nuke.toNode('preferences')\['GridWidth'].getValue()) , int(nuke.toNode('preferences')\['GridHeight'].getValue()) ]\n\n\t\tfilterCheck = goStore\['filterNonReverse'].getValue().split(',')\n\t\tfilter3DNodes = goStore\['filter3DNodes'].value().split(',')\n\t\texNodes = \[]\n\n\t\txportSC = nuke.nodes.Scene()\n\t\texNodes.append( xportSC )\n\n\t\tprogBar = nuke.ProgressTask('Extracting instances...')\n\t\tjobCount = 0\n\t\tjobTotal = len( selAX )\n\n\t\tcount = 0\n\t\tfor node in selAX :\n\t\t\t### progress bar\n\t\t\tjobCount += 1\n\t\t\tprogShow = int(jobCount/jobTotal * 100)\n\t\t\tif progBar.isCancelled() :\n\t\t\t\tbreak;\n\t\t\tprogBar.setProgress(progShow)\n\t\t\t#################\n\n\t\t\ttry :\n\t\t\t\texColor = thisGRP\['exColor'].value()\n\t\t\texcept :\n\t\t\t\texColor = False\n\n\t\t\tif exColor :\n\t\t\t\txportAX = nuke.nodes.Axis(\n\t\t\t\t\t\t\t\txpos = int( thisGRP.xpos() + space\[0] * ( count + 1 ) ) , \n\t\t\t\t\t\t\t\typos = int( thisGRP.ypos() + space\[1] )\n\t\t\t\t\t\t\t\t)\n\t\t\t\txportMULT = nuke.nodes.Multiply(\n\t\t\t\t\t\t\t\tchannels = 'rgb' ,\n\t\t\t\t\t\t\t\txpos = int( thisGRP.xpos() + space\[0] * ( count + 1 ) ) , \n\t\t\t\t\t\t\t\typos = int( thisGRP.ypos() )\n\t\t\t\t\t\t\t\t)\n\t\t\t\txportMULT\['value'].setSingleValue(False)\n\t\t\t\twith thisGRP :\n\t\t\t\t\txportMULT\['value'].setValue( nuke.toNode( 'cc_\{0\}'.format(node.name()\[3:]) )\['value'].getValue() )\n\t\t\t\texNodes.append( xportAX )\n\t\t\t\texNodes.append( xportMULT )\n\t\t\telse :\n\t\t\t\txportAX = nuke.nodes.Axis(\n\t\t\t\t\txpos = int( thisGRP.xpos() + space\[0] * ( count + 1 ) ) , \n\t\t\t\t\typos = int( thisGRP.ypos() )\n\t\t\t\t\t)\n\t\t\t\texNodes.append( xportAX )\n\n\t\t\txportSC.setInput( count, xportAX )\n\t\t\tcount += 1\n\n\t\t\ttry :\n\t\t\t\twith thisGRP :\n\t\t\t\t\tAnimRange = \[int(i) for i in goStore\['aniRNG'].value().split('-')]\n\n\t\t\t\tif thisGRP\['exTranslate'].value() :\n\t\t\t\t\txportAX\['translate'].setAnimated()\n\t\t\t\tif thisGRP\['exRotate'].value() :\n\t\t\t\t\txportAX\['rotate'].setAnimated()\n\t\t\t\tif thisGRP\['exScale'].value() :\n\t\t\t\t\txportAX\['scaling'].setAnimated()\n\n\t\t\t\tfor ctime in xrange( int(AnimRange\[0]) , int(AnimRange\[1]+1) , 1  ) :\n\t\t\t\t\tmainstream = upstreamNodes( node , filter3DNodes )\n\t\t\t\t\tmMTX = unify( mainstream , ctime )\n\t\t\t\t\tform = mtx2value( mMTX )\n\n\t\t\t\t\tif thisGRP\['exTranslate'].value() :\n\t\t\t\t\t\tfor i in range( 3 ) :\n\t\t\t\t\t\t\txportAX\['translate'].setValueAt( form\[0]\[i] , ctime, i )\n\t\t\t\t\tif thisGRP\['exRotate'].value() :\n\t\t\t\t\t\tfor i in range( 3 ) :\n\t\t\t\t\t\t\txportAX\['rotate'].setValueAt( form\[1]\[i] , ctime, i )\n\t\t\t\t\tif thisGRP\['exScale'].value() :\n\t\t\t\t\t\tfor i in range( 3 ) :\n\t\t\t\t\t\t\txportAX\['scaling'].setValueAt( form\[2]\[i] , ctime, i )\n\t\t\texcept :\n\t\t\t\tmainstream = upstreamNodes( node , filter3DNodes )\n\t\t\t\tmMTX = unify( mainstream , nuke.frame() )\n\t\t\t\tform = mtx2value( mMTX )\n\n\t\t\t\tif thisGRP\['exTranslate'].value() :\n\t\t\t\t\txportAX\['translate'].setValue( form\[0] )\n\t\t\t\tif thisGRP\['exRotate'].value() :\n\t\t\t\t\txportAX\['rotate'].setValue( form\[1] )\n\t\t\t\tif thisGRP\['exScale'].value() :\n\t\t\t\t\txportAX\['scaling'].setValue( form\[2] )\n\n\t\t##### deselect all Nodes\n\t\twith getLevel() :\n\t\t\tsavedSelected = \[]\n\t\t\tfor node in nuke.allNodes() :\n\t\t\t\tif node\['selected'].value()\t:\n\t\t\t\t\tsavedSelected.append( node )\n\t\t\t\tnode.setSelected( False )\n\n\t\t##### set backdrop\n\t\tfor node in exNodes :\n\t\t\tnode.setSelected( True )\n\n\t\tautoBackdrop_mod( thisGRP.name() , int( thisGRP\['tile_color'].getValue() ) )\n\n\t\tfor node in exNodes :\n\t\t\tnode.setSelected( False )\n\n\t\t##### restore selected node\n\t\tfor node in savedSelected :\n\t\t\tnode.setSelected( True )\n\n\t\tdel progBar, jobCount, jobTotal, progShow\n\t\t\n\telse :\n\t\tnuke.message('No selected axis found.<br><br>Process denied...')\n\nelse :\n\tnuke.message('No translate, rotate and scale checked, no axis will be extract.<br><br>Process denied...')"}
  addUserKnob {22 cpCode03 T "# used to delete selected axis\nselAX = \[]\nfor node in nuke.allNodes('Axis') :\n   if node.name()\[:3] == 'ax_' and node\['selected'].getValue() :\n      for link in node.dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependencies() :\n         if link.Class() != 'Input' :\n            selAX.append( link )\n      if node.dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependent(nuke.INPUTS, forceEvaluate=False)\[0].Class() == 'ApplyMaterial' :\n         for link in node.dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependencies() :\n            selAX.append( link )\n         selAX.append( node.dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependent(nuke.INPUTS, forceEvaluate=False)\[0] )\n      else :\n         selAX.append( node.dependent(nuke.INPUTS, forceEvaluate=False)\[0] )\n\nif len( selAX ) :\n   progBar = nuke.ProgressTask('Removing instances...')\n   jobCount = 0\n   jobTotal = len( selAX )\n\n   for rmNode in selAX :\n      ### progress bar\n      jobCount += 1\n      progShow = int(jobCount/jobTotal * 100)\n      if progBar.isCancelled() :\n         break;\n      progBar.setProgress(progShow)\n      #################\n\n      for i in range( rmNode.inputs() ) :\n         rmNode.setInput( i, None )\n      if rmNode.Class() == 'Axis' :\n         nuke.thisGroup()\['info_inst'].setValue( str( int( nuke.thisGroup()\['info_inst'].value() ) -1 ) )\n      nuke.delete( rmNode )\n\n   del progBar, jobCount, jobTotal, progShow\nelse :\n   nuke.message('No instance selected. Nothing deleted.')" +STARTLINE}
  addUserKnob {22 cpCode04 -STARTLINE T "# used to set user layer and frame override on selected instances\nselAX = \[]\nfor node in nuke.allNodes('Axis') :\n   if node.name()\[:3] == 'ax_' and node\['selected'].getValue() :\n      for link in node.dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependencies() :\n         if link.Class() != 'Input' :\n            selAX.append( link )\n      if node.dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependent(nuke.INPUTS, forceEvaluate=False)\[0].Class() == 'ApplyMaterial' :\n         for link in node.dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependencies() :\n            selAX.append( link )\n         selAX.append( node.dependent(nuke.INPUTS, forceEvaluate=False)\[0].dependent(nuke.INPUTS, forceEvaluate=False)\[0] )\n      else :\n         selAX.append( node.dependent(nuke.INPUTS, forceEvaluate=False)\[0] )\n\nif len( selAX ) :\n   jobCount = 0\n   jobTotal = len( selAX )\n\n   if jobTotal:\n      input_start = nuke.thisNode()\[\"range_start\"].getValue()\n      input_end = nuke.thisNode()\[\"range_end\"].getValue()\n      input_frame = nuke.thisNode()\[\"user_input_frame\"].getValue()\n      input_layer = int(nuke.thisNode()\[\"user_layer_list\"].getValue() + 1) # list layers start at index 1\n\n   for inputChange in selAX :\n      ### progress bar\n      jobCount += 1\n      dependent_nodes =  inputChange.dependent(nuke.INPUTS, forceEvaluate=False)\n      for node in dependent_nodes:\n         if node.Class() in \['TransformGeo']:\n            timeoffset_node = node.input(0)\n            framehold_node = timeoffset_node.input(0)\n\n            if nuke.thisNode().knob('input_type').getValue():\n               # image seq is selected, adjusting timeoffset\n               timeoffset_node\['time_offset'].clearAnimated()\n               timeoffset_node\['time_offset'].setValue(input_frame)\n            else:\n               # turntable is selected, adjusting framehold\n               framehold_node\[\"first_frame\"].clearAnimated()\n               framehold_node\[\"first_frame\"].setValue(input_frame)\n\n            switch_node = framehold_node.input(0).input(1)\n            switch_node\[\"which\"].clearAnimated()\n            switch_node\[\"which\"].setValue(input_layer)\n\n   del jobCount, jobTotal\nelse :\n   nuke.message('No instance selected.')\n"}
  addUserKnob {22 cpCode05 T "# Knobs-Changed-Callback on mSnap\ndef update_positions():\n    pts_pos_list = eval(nuke.thisNode()\[\"pts_pos\"].getText())\n    current_seed = int(nuke.thisNode()\[\"seed_controller\"].getValue())\n    with nuke.thisGroup():\n        for node in nuke.allNodes('Axis'):\n            if node.name() != 'worldTransform':\n                current_axid = int(node\[\"axid\"].getValue())\n                try:\n                    pos = \[pts_pos_list\[current_seed]\[current_axid]\[0],\n                           pts_pos_list\[current_seed]\[current_axid]\[1],\n                           pts_pos_list\[current_seed]\[current_axid]\[2]]\n                    node\['translate'].setValue(pos)\n                except IndexError:\n                    pass\n\nif nuke.thisKnob().name() == 'seed_controller':\n    update_positions()\nelif nuke.thisKnob().name() == 'input_type':\n    if nuke.thisKnob().getValue():\n        # image seq active\n        nuke.thisNode().knob('range_start').setVisible(False)\n        nuke.thisNode().knob('range_end').setVisible(False)\n        nuke.thisNode().knob('offset_end').setVisible(True)\n        nuke.thisNode().knob('user_input_frame').setLabel(' frame offset')\n    else:\n        nuke.thisNode().knob('range_start').setVisible(True)\n        nuke.thisNode().knob('range_end').setVisible(True)\n        nuke.thisNode().knob('offset_end').setVisible(False)\n        nuke.thisNode().knob('user_input_frame').setLabel(' turntable frame')\nelif nuke.thisKnob().name() in \['lookAt_override_x', 'lookAt_override_y', 'lookAt_override_z']:\n    with nuke.thisGroup():\n        for tgeo_node in nuke.allNodes(\"TransformGeo\"):\n            tgeo_node.knob('look_rotate_x').setValue(nuke.thisNode().knob('lookAt_override_x').getValue())\n            tgeo_node.knob('look_rotate_y').setValue(nuke.thisNode().knob('lookAt_override_y').getValue())\n            tgeo_node.knob('look_rotate_z').setValue(nuke.thisNode().knob('lookAt_override_z').getValue())" +STARTLINE}
  addUserKnob {22 cpCode06 -STARTLINE T "# Knobs-Changed-Callback on Vegetation Loader\ndef find_topnode(node):\n    if node.input(0):\n        return find_topnode(node.input(0))\n    else:\n        return node\n\ndef update_inputs():\n    channel_list = \[]\n    n = nuke.thisNode()\n    maxIndex = n.maximumInputs() - 1\n    layer_naming_convention_index = int(n\['layer_naming_convention'].getValue())\n    input_naming_pos_index = int(n\['input_naming_pos'].getValue())\n\n    if n.input(maxIndex) is not None:\n        # Last input is connected to something. Add a new one.\n        with n:\n            nuke.nodes.Input()\n    else:\n        # Find disconnected inputs at the end to remove\n        lastIndex = n.inputs()\n        if lastIndex < maxIndex:\n            for inputNode in nuke.allNodes('Input', group=n):\n                if inputNode\['number'].value() > lastIndex:\n                    # edge case: last input unplugged AND input number is not 1\n                    if inputNode.dependent(nuke.INPUTS, forceEvaluate=False):\n                        for connected_node in inputNode.dependent(nuke.INPUTS, forceEvaluate=False):\n                            nuke.delete(connected_node)\n                    nuke.delete(inputNode)\n\n    # check if all inputs are connected and have right channels\n    with n:\n        for input_node in nuke.allNodes(\"Input\"):\n            if n.input(int(input_node\[\"number\"].getValue())):\n                # get channel name\n                connected_node = n.input(int(input_node\[\"number\"].getValue()))\n                top_input = find_topnode(connected_node)\n\n                if layer_naming_convention_index == 2:\n                    # using metadata name for channel naming\n                    try:\n                        channel_name = connected_node.metadata()\[\"vegetationLayer\"]\n                    except KeyError:\n                        nuke.message(\n                            \"You need to add the vegetationLayer to the input's metadata. <br>\"\n                            \"You can use the button to create a prepared metadata layer setup node\")\n                        return\n                elif layer_naming_convention_index ==1:\n                    # using ieDisplayName for channel naming\n                    if top_input.knob('ieDisplayName'):\n                        channel_name = top_input\['ieDisplayName'].getValue().split(\"_\")\[input_naming_pos_index]\n                    else:\n                        nuke.message(\n                            'You are trying to use the Render Pass Loader Name for your layer naming.<br>'\n                            'Make sure the topmost node of your input is a render pass loader or '\n                            'choose another layer naming convention')\n                        return\n                else:\n                    # using input node name for layer naming\n                    channel_name = top_input.name().split(\"_\")\[input_naming_pos_index]\n\n                normal_channel_name = \"\{\}_normal\".format(channel_name)\n                channel_list.append(channel_name)\n\n                # create channels\n                nuke.Layer(channel_name, \['\{\}.red'.format(channel_name), '\{\}.green'.format(channel_name),\n                                          '\{\}.blue'.format(channel_name), '\{\}.alpha'.format(channel_name)])\n                nuke.Layer(normal_channel_name, \['\{\}.red'.format(normal_channel_name), '\{\}.green'.format(normal_channel_name),\n                                          '\{\}.blue'.format(normal_channel_name), '\{\}.alpha'.format(normal_channel_name)])\n\n                # add / adjust shuffle node\n                if input_node.dependent(nuke.INPUTS, forceEvaluate=False):\n                    output_node = input_node.dependent(nuke.INPUTS, forceEvaluate=False)\[0]\n                    if output_node.Class() == \"Shuffle2\":\n                        shuffle_node = output_node\n                        shuffle_node\[\"out1\"].setValue(channel_name)\n                    # also set normal shuffle settings\n                    output_node = input_node.dependent(nuke.INPUTS, forceEvaluate=False)\[1]\n                    if output_node.Class() == \"Shuffle2\":\n                        shuffle_normal_node = output_node\n                        shuffle_normal_node\[\"in1\"].setValue(\"normal\")\n                        shuffle_normal_node\[\"out1\"].setValue(normal_channel_name)\n                else:\n                    # input node has no out connections - create shuffle\n                    shuffle_node = nuke.nodes.Shuffle2()\n                    shuffle_node.setInput(0, input_node)\n                    shuffle_node\[\"out1\"].setValue(channel_name)\n                    # additional shuffle for normals\n                    shuffle_normal_node = nuke.nodes.Shuffle2()\n                    shuffle_normal_node.setInput(0, input_node)\n                    shuffle_normal_node\[\"in1\"].setValue(\"normal\")\n                    shuffle_normal_node\[\"out1\"].setValue(normal_channel_name)\n\n            else:\n                # no (longer) any input\n                for connected_node in input_node.dependent(nuke.INPUTS, forceEvaluate=False):\n                    # remove connections\n                    connected_node.setInput(0, None)\n                    nuke.delete(connected_node)\n\n        merge_node = nuke.toNode(\"Vegetation_Layer_Merge\")\n        # disconnect layer merge\n        for index in range(0, merge_node.inputs()):\n            merge_node.setInput(index, None)\n        # connect Shuffles to Layer Merge\n        input_counter = 0\n        for shuffle_node in nuke.allNodes(\"Shuffle2\"):\n            if input_counter == 2:\n                input_counter += 1\n            merge_node.setInput(input_counter, shuffle_node)\n            input_counter += 1\n\n        # set layer list pulldown options\n        channel_list.reverse()\n        n\[\"input_layer_list\"].setValues(channel_list)\n\nif nuke.thisKnob().name() == 'active_input_updates':\n    if nuke.thisKnob().getValue() == 0.0:\n        nuke.thisKnob().setLabel('<font color=gray>&nbsp;<b>Input Updates Inactive')\n        nuke.thisKnob().clearFlag(0)\n        nuke.thisNode().knob('label').setValue('')\n    else:\n        nuke.thisKnob().setLabel('<font color=green>&nbsp;<b>Input Updates Active')\n        nuke.thisKnob().clearFlag(0)\n        nuke.thisNode().knob('label').setValue('<font color=green>UPDATE ACTIVE')\n        update_inputs()\n\nif nuke.thisKnob().name() == 'inputChange':\n    if nuke.thisNode().knob('active_input_updates').getValue():\n        update_inputs()\n\nif nuke.thisKnob().name() == 'input_naming_pos':\n    if nuke.thisNode().knob('active_input_updates').getValue():\n        update_inputs()\n\nif nuke.thisKnob().name() == 'layer_naming_convention':\n    if nuke.thisKnob().getValue() == 2.0:\n        nuke.thisNode()\['create_metadata_layer_node'].setVisible(True)\n        nuke.thisNode()\['input_naming_pos'].setEnabled(False)\n    else:\n        nuke.thisNode()\['create_metadata_layer_node'].setVisible(False)\n        nuke.thisNode()\['input_naming_pos'].setEnabled(True)\n\n    if nuke.thisNode().knob('active_input_updates').getValue():\n        update_inputs()\n"}
  addUserKnob {22 cpCode07 T "# update channel list in linked Node (outside grp)\nn = nuke.thisNode()\nchannel_list = n\['input_layer_list'].values()\n\nprogBar = nuke.ProgressTask('Updating Scatter GRP')\nprogBar.setProgress(0)\n\nlinked_nodes = n.dependent(nuke.EXPRESSIONS)\n# workaround for buggy behaviour that expression linked node\n# isn't registered if it has just been created and not yet interacted with\nif not linked_nodes:\n    connected_nodes = n.dependent()\n    for connection in connected_nodes:\n        if connection.knob(\"linked_input_layer_list\") and connection not in linked_nodes:\n            linked_nodes.append(connection)\n\nif not linked_nodes:\n    # linked connection might no longer be available\n    nuke.message('Linked Scatter Node could not be found.<br>'\n                 'You can connect the VegetationLoader directly <br>'\n                 'to the tex input of the scatter node to fix this')\n\nfor linked_node in linked_nodes:\n    if linked_node\[\"linked_input_layer_list\"]:\n        linked_node\[\"linked_input_layer_list\"].setValues(channel_list)\n    if linked_node\[\"number_of_layers\"]:\n        linked_node\[\"number_of_layers\"].setValue(len(channel_list))\n    if linked_node\[\"user_layer_list\"]:\n        linked_node\[\"user_layer_list\"].setValues(channel_list)\n\n    # update shuffles inside the linked Node\n    with linked_node:\n        tex_input = nuke.toNode('tex')\n        input_index = 1\n        for channel in channel_list:\n            keep_name = \"Keep_Layer_\{\}\".format(channel)\n            shuffle_name = \"Shuffle_Layer_\{\}\".format(channel)\n            normal_layer = \"\{\}_normal\".format(channel)\n            normal_shuffle_name = \"Shuffle_Normal_\{\}\".format(channel)\n            remove_normal_name = \"Remove_Normal_Layer_\{\}\".format(channel)\n            keep_node = nuke.toNode(keep_name)\n            channel_shuffle = nuke.toNode(shuffle_name)\n            normal_shuffle = nuke.toNode(normal_shuffle_name)\n            remove_normal_node = nuke.toNode(remove_normal_name)\n            if not keep_node:\n                keep_node = nuke.nodes.Remove()\n                keep_node\['name'].setValue(keep_name)\n            if not channel_shuffle:\n                channel_shuffle = nuke.nodes.Shuffle2()\n                channel_shuffle\['name'].setValue(shuffle_name)\n            if not normal_shuffle:\n                normal_shuffle = nuke.nodes.Shuffle2()\n                normal_shuffle\['name'].setValue(normal_shuffle_name)\n            if not remove_normal_node:\n                remove_normal_node = nuke.nodes.Remove()\n                remove_normal_node\['name'].setValue(remove_normal_name)\n            keep_node.knob('operation').setValue('keep')\n            keep_node.knob('channels').setValue(channel)\n            keep_node.knob('channels2').setValue(normal_layer)\n            channel_shuffle\['in1'].setValue(channel)\n            normal_shuffle\['in1'].setValue(normal_layer)\n            normal_shuffle\['out1'].setValue('normal')\n            remove_normal_node.knob('channels').setValue(normal_layer)\n\n            keep_node.setInput(0, tex_input)\n            channel_shuffle.setInput(0, keep_node)\n            normal_shuffle.setInput(0, channel_shuffle)\n            remove_normal_node.setInput(0, normal_shuffle)\n\n            for switch_node in nuke.allNodes('Switch'):\n                switch_node.setInput(input_index, remove_normal_node)\n\n            progress = int(input_index / len(channel_list) * 100)\n            progBar.setProgress(progress)\n\n            input_index += 1\n\nprogBar.setProgress(100)\ndel progBar\n" +STARTLINE}
  addUserKnob {22 cpCode08 -STARTLINE T "# used to remove rotation and scale expressions from selected instances\nselAX = \[]\nfor node in nuke.allNodes('Axis') :\n   if node.name()\[:3] == 'ax_' and node\['selected'].getValue() :\n      selAX.append(node)\n\nif len( selAX ) :\n   for ax in selAX :\n      ax\[\"scaling\"].clearAnimated()\n      ax\[\"rotate\"].clearAnimated()\n      ax\[\"uniform_scale\"].clearAnimated()\n\nelse :\n   nuke.message('No instance selected.')\n"}
  addUserKnob {22 cpCode09 T "# function to create ModifyMetadata node from Vegetation Loader\nthisNode = nuke.thisNode()\nwith nuke.root():\n    newName = 'VegetationLayer_InsertLayerNameHere1'\n    key = \"vegetationLayer\"\n    value = \"\{\[join \[lrange \[split \[value name] _ ] 1 end] _ ]\}\"\n    meta_node = nuke.createNode(\"ModifyMetaData\", \"metadata \{\{set %s %s\}\}\" % (key, value))\n    meta_node.setName(newName)\n    meta_node\['tile_color'].setValue(int(thisNode\['tile_color'].getValue()))\n    meta_node.knob('label').setValue('\[join \[lrange \[split \[value name] _ ] 1 end] \"_\"]')\n" +STARTLINE}
  addUserKnob {22 cpCode10 -STARTLINE T "cpCode09 = \"\"\"\n# function to create ModifyMetadata node from Vegetation Loader\nthisNode = nuke.thisNode()\nwith nuke.root():\n    newName = 'VegetationLayer_InsertLayerNameHere1'\n    key = \"vegetationLayer\"\n    value = \"\{\[join \[lrange \[split \[value name] _ ] 1 end] _ ]\}\"\n    meta_node = nuke.createNode(\"ModifyMetaData\", \"metadata \{\{set %s %s\}\}\" % (key, value))\n    meta_node.setName(newName)\n    meta_node\['tile_color'].setValue(int(thisNode\['tile_color'].getValue()))\n    meta_node.knob('label').setValue('\[join \[lrange \[split \[value name] _ ] 1 end] \"_\"]')\n\"\"\"\n\ncpCode07 = \"\"\"\n# update channel list in linked Node (outside grp)\nn = nuke.thisNode()\nchannel_list = n\['input_layer_list'].values()\n\nprogBar = nuke.ProgressTask('Updating Scatter GRP')\nprogBar.setProgress(0)\n\nlinked_nodes = n.dependent(nuke.EXPRESSIONS)\n# workaround for buggy behaviour that expression linked node\n# isn't registered if it has just been created and not yet interacted with\nif not linked_nodes:\n    connected_nodes = n.dependent()\n    for connection in connected_nodes:\n        if connection.knob(\"linked_input_layer_list\") and connection not in linked_nodes:\n            linked_nodes.append(connection)\n\nif not linked_nodes:\n    # linked connection might no longer be available\n    nuke.message('Linked Scatter Node could not be found.<br>'\n                 'You can connect the VegetationLoader directly <br>'\n                 'to the tex input of the scatter node to fix this')\n\nfor linked_node in linked_nodes:\n    if linked_node\[\"linked_input_layer_list\"]:\n        linked_node\[\"linked_input_layer_list\"].setValues(channel_list)\n    if linked_node\[\"number_of_layers\"]:\n        linked_node\[\"number_of_layers\"].setValue(len(channel_list))\n    if linked_node\[\"user_layer_list\"]:\n        linked_node\[\"user_layer_list\"].setValues(channel_list)\n\n    # update shuffles inside the linked Node\n    with linked_node:\n        tex_input = nuke.toNode('tex')\n        input_index = 1\n        for channel in channel_list:\n            shuffle_name = \"Shuffle_Layer_\{\}\".format(channel)\n            normal_layer = \"\{\}_normal\".format(channel)\n            normal_shuffle_name = \"Shuffle_Normal_\{\}\".format(channel)\n            channel_shuffle = nuke.toNode(shuffle_name)\n            normal_shuffle = nuke.toNode(normal_shuffle_name)\n            if not channel_shuffle:\n                channel_shuffle = nuke.nodes.Shuffle2()\n                channel_shuffle\['name'].setValue(shuffle_name)\n            if not normal_shuffle:\n                normal_shuffle = nuke.nodes.Shuffle2()\n                normal_shuffle\['name'].setValue(normal_shuffle_name)\n            channel_shuffle\['in1'].setValue(channel)\n            normal_shuffle\['in1'].setValue(normal_layer)\n            normal_shuffle\['out1'].setValue('normal')\n\n            channel_shuffle.setInput(0, tex_input)\n            normal_shuffle.setInput(0, channel_shuffle)\n\n            for switch_node in nuke.allNodes('Switch'):\n                switch_node.setInput(input_index, normal_shuffle)\n\n            progress = int(input_index / len(channel_list) * 100)\n            progBar.setProgress(progress)\n\n            input_index += 1\n\nprogBar.setProgress(100)\ndel progBar\n\"\"\"\n\ncpCode06 = \"\"\"\n# Knobs-Changed-Callback on Vegetation Loader\ndef find_topnode(node):\n    if node.input(0):\n        return find_topnode(node.input(0))\n    else:\n        return node\n\ndef update_inputs():\n    channel_list = \[]\n    n = nuke.thisNode()\n    maxIndex = n.maximumInputs() - 1\n    layer_naming_convention_index = int(n\['layer_naming_convention'].getValue())\n    input_naming_pos_index = int(n\['input_naming_pos'].getValue())\n\n    if n.input(maxIndex) is not None:\n        # Last input is connected to something. Add a new one.\n        with n:\n            nuke.nodes.Input()\n    else:\n        # Find disconnected inputs at the end to remove\n        lastIndex = n.inputs()\n        if lastIndex < maxIndex:\n            for inputNode in nuke.allNodes('Input', group=n):\n                if inputNode\['number'].value() > lastIndex:\n                    # edge case: last input unplugged AND input number is not 1\n                    if inputNode.dependent(nuke.INPUTS, forceEvaluate=False):\n                        for connected_node in inputNode.dependent(nuke.INPUTS, forceEvaluate=False):\n                            nuke.delete(connected_node)\n                    nuke.delete(inputNode)\n\n    # check if all inputs are connected and have right channels\n    with n:\n        for input_node in nuke.allNodes(\"Input\"):\n            if n.input(int(input_node\[\"number\"].getValue())):\n                # get channel name\n                connected_node = n.input(int(input_node\[\"number\"].getValue()))\n                top_input = find_topnode(connected_node)\n\n                if layer_naming_convention_index == 2:\n                    # using metadata name for channel naming\n                    try:\n                        channel_name = connected_node.metadata()\[\"vegetationLayer\"]\n                    except KeyError:\n                        nuke.message(\n                            \"You need to add the vegetationLayer to the input's metadata. <br>\"\n                            \"You can use the button to create a prepared metadata layer setup node\")\n                        return\n                elif layer_naming_convention_index ==1:\n                    # using ieDisplayName for channel naming\n                    if top_input.knob('ieDisplayName'):\n                        channel_name = top_input\['ieDisplayName'].getValue().split(\"_\")\[input_naming_pos_index]\n                    else:\n                        nuke.message(\n                            'You are trying to use the Render Pass Loader Name for your layer naming.<br>'\n                            'Make sure the topmost node of your input is a render pass loader or '\n                            'choose another layer naming convention')\n                        return\n                else:\n                    # using input node name for layer naming\n                    channel_name = top_input.name().split(\"_\")\[input_naming_pos_index]\n\n                normal_channel_name = \"\{\}_normal\".format(channel_name)\n                channel_list.append(channel_name)\n\n                # create channels\n                nuke.Layer(channel_name, \['\{\}.red'.format(channel_name), '\{\}.green'.format(channel_name),\n                                          '\{\}.blue'.format(channel_name), '\{\}.alpha'.format(channel_name)])\n                nuke.Layer(normal_channel_name, \['\{\}.red'.format(normal_channel_name), '\{\}.green'.format(normal_channel_name),\n                                          '\{\}.blue'.format(normal_channel_name), '\{\}.alpha'.format(normal_channel_name)])\n\n                # add / adjust shuffle node\n                if input_node.dependent(nuke.INPUTS, forceEvaluate=False):\n                    output_node = input_node.dependent(nuke.INPUTS, forceEvaluate=False)\[0]\n                    if output_node.Class() == \"Shuffle2\":\n                        shuffle_node = output_node\n                        shuffle_node\[\"out1\"].setValue(channel_name)\n                    # also set normal shuffle settings\n                    output_node = input_node.dependent(nuke.INPUTS, forceEvaluate=False)\[1]\n                    if output_node.Class() == \"Shuffle2\":\n                        shuffle_normal_node = output_node\n                        shuffle_normal_node\[\"in1\"].setValue(\"normal\")\n                        shuffle_normal_node\[\"out1\"].setValue(normal_channel_name)\n                else:\n                    # input node has no out connections - create shuffle\n                    shuffle_node = nuke.nodes.Shuffle2()\n                    shuffle_node.setInput(0, input_node)\n                    shuffle_node\[\"out1\"].setValue(channel_name)\n                    # additional shuffle for normals\n                    shuffle_normal_node = nuke.nodes.Shuffle2()\n                    shuffle_normal_node.setInput(0, input_node)\n                    shuffle_normal_node\[\"in1\"].setValue(\"normal\")\n                    shuffle_normal_node\[\"out1\"].setValue(normal_channel_name)\n\n            else:\n                # no (longer) any input\n                for connected_node in input_node.dependent(nuke.INPUTS, forceEvaluate=False):\n                    # remove connections\n                    connected_node.setInput(0, None)\n                    nuke.delete(connected_node)\n\n        merge_node = nuke.toNode(\"Vegetation_Layer_Merge\")\n        # disconnect layer merge\n        for index in range(0, merge_node.inputs()):\n            merge_node.setInput(index, None)\n        # connect Shuffles to Layer Merge\n        input_counter = 0\n        for shuffle_node in nuke.allNodes(\"Shuffle2\"):\n            if input_counter == 2:\n                input_counter += 1\n            merge_node.setInput(input_counter, shuffle_node)\n            input_counter += 1\n\n        # set layer list pulldown options\n        channel_list.reverse()\n        n\[\"input_layer_list\"].setValues(channel_list)\n\nif nuke.thisKnob().name() == 'active_input_updates':\n    if nuke.thisKnob().getValue() == 0.0:\n        nuke.thisKnob().setLabel('<font color=gray>&nbsp;<b>Input Updates Inactive')\n        nuke.thisKnob().clearFlag(0)\n        nuke.thisNode().knob('label').setValue('')\n    else:\n        nuke.thisKnob().setLabel('<font color=green>&nbsp;<b>Input Updates Active')\n        nuke.thisKnob().clearFlag(0)\n        nuke.thisNode().knob('label').setValue('<font color=green>UPDATE ACTIVE')\n        update_inputs()\n\nif nuke.thisKnob().name() == 'inputChange':\n    if nuke.thisNode().knob('active_input_updates').getValue():\n        update_inputs()\n\nif nuke.thisKnob().name() == 'input_naming_pos':\n    if nuke.thisNode().knob('active_input_updates').getValue():\n        update_inputs()\n\nif nuke.thisKnob().name() == 'layer_naming_convention':\n    if nuke.thisKnob().getValue() == 2.0:\n        nuke.thisNode()\['create_metadata_layer_node'].setVisible(True)\n        nuke.thisNode()\['input_naming_pos'].setEnabled(False)\n    else:\n        nuke.thisNode()\['create_metadata_layer_node'].setVisible(False)\n        nuke.thisNode()\['input_naming_pos'].setEnabled(True)\n\n    if nuke.thisNode().knob('active_input_updates').getValue():\n        update_inputs()\n\"\"\"\n\ndef create_vegetation_loader(_name, _thisG):\n    availableName = findAvailableName(_name)\n    newName = _name + '_' + str(availableName)\n\n    xspace = int(nuke.toNode('preferences')\['GridWidth'].getValue())\n    yspace = int(nuke.toNode('preferences')\['GridHeight'].getValue())\n\n    random.seed(int(time.time()))\n\n    veg_loader_GRP = nuke.nodes.Group(\n        name=newName,\n        tile_color=int(thisGRP\['tile_color'].getValue()),\n        xpos=thisGRP.xpos() + (xspace + random.randint(0, xspace)),\n        ypos=thisGRP.ypos() - (yspace*4)\n    )\n\n    veg_loader_GRP.addKnob(nuke.Tab_Knob('tab_vegetation', 'Vegetation'))\n    # Active Input Checkbox and Indicator\n    veg_loader_GRP.addKnob(nuke.Boolean_Knob('active_input_updates', '<font color=green>&nbsp;<b>Input Updates Active'))\n    veg_loader_GRP\['active_input_updates'].setValue(1)\n    veg_loader_GRP.knob('label').setValue('<font color=green>UPDATE ACTIVE')\n    # Dropdown for choosing automatic layer naming convention\n    veg_loader_GRP.addKnob(nuke.Enumeration_Knob(\"layer_naming_convention\", \"Layer Naming Convention\",\n                                                 \[\"Input Node Name\", \"Render Pass Loader Name\",\n                                                  \"Metadata Vegetation Layer\"]))\n    veg_loader_GRP\['layer_naming_convention'].setValue(1)\n    # Add Button for MetadataNode Creation\n    veg_loader_GRP.addKnob(nuke.PyScript_Knob('create_metadata_layer_node', 'create Metadata-Layer node', cpCode09))\n    veg_loader_GRP\['create_metadata_layer_node'].setVisible(False)\n\n    veg_loader_GRP.addKnob(nuke.Int_Knob('input_naming_pos', 'Input Name Position'))\n    veg_loader_GRP.addKnob(nuke.Text_Knob('spacer1', '', '<br>'))\n    veg_loader_GRP.addKnob(nuke.Enumeration_Knob(\"input_layer_list\", \"Vegetation Layers\", \[]))\n    veg_loader_GRP.addKnob(nuke.PyScript_Knob('update_scatter_grp', 'update Scatter Grp', cpCode07))\n\n    # add version that was used to create this note for debugging purposes\n    veg_loader_GRP.addKnob(nuke.Tab_Knob('tab_info', 'Info'))\n    veg_loader_GRP.addKnob(nuke.Text_Knob('version_info', _thisG\['version_info'].value()))\n    # add documentation link\n    veg_loader_GRP.addKnob(nuke.Text_Knob('documentation_info', '<font color=cyan>documentation :</font>',\n                                          \"<a href ='http://docsie/index.php/MScatterGeo'><font color='orange'>Docsie</font ></a>\"))\n\n\n    with veg_loader_GRP:\n        # create output node\n        out_node = nuke.nodes.Output()\n\n        # create merge node with correct settings\n        merge_node = nuke.nodes.Merge2()\n        merge_node\[\"name\"].setValue(\"Vegetation_Layer_Merge\")\n        merge_node\[\"Achannels\"].setValue(\"none\")\n        merge_node\[\"Bchannels\"].setValue(\"none\")\n        merge_node\[\"output\"].setValue(\"none\")\n        merge_node\[\"also_merge\"].setValue(\"all\")\n        out_node.setInput(0, merge_node)\n\n        # create first input (not connected to anything)\n        in1_node = nuke.nodes.Input()\n\n    # set up callback function with veg loader input logic\n    veg_loader_GRP\['knobChanged'].setValue(cpCode06)\n\n    return veg_loader_GRP\n\nscatter_grp = nuke.thisNode()\nwith getLevel():\n    if scatter_grp.knob('linked_input_layer_list'):\n        # print nuke.dependencies(scatter_grp, nuke.LINKINPUTS)\n        print scatter_grp.knob('linked_input_layer_list').toScript()\n        linked_veg_node = scatter_grp.knob('linked_input_layer_list').toScript()\[2:-2].split('.')\[0]\n        if nuke.toNode(linked_veg_node):\n            if nuke.ask('This Node is currently linked to \{\}<br>Do you want to create a new VegetationLoader and link it instead?'.format(linked_veg_node)):\n                new_veg_loader = create_vegetation_loader('VegetationLoader', scatter_grp)\n                link_name = new_veg_loader.knob('input_layer_list').fullyQualifiedName()\n                scatter_grp.knob('linked_input_layer_list').setExpression(link_name)\n        else:\n            new_veg_loader = create_vegetation_loader('VegetationLoader', scatter_grp)\n            link_name = new_veg_loader.knob('input_layer_list').fullyQualifiedName()\n            scatter_grp.knob('linked_input_layer_list').setExpression(link_name)\n            "}
  addUserKnob {22 cpCode11 T "\ndef create_crypto_from_mask_channels(mask_channel_list,_thisG):\n    xspace = int(nuke.toNode('preferences')\['GridWidth'].getValue())\n    yspace = int(nuke.toNode('preferences')\['GridHeight'].getValue())\n\n    random.seed(int(time.time()))\n\n    veg_crypto_GRP = nuke.nodes.Group(\n        tile_color=int(thisGRP\['tile_color'].getValue()),\n        xpos=thisGRP.xpos() + (xspace + random.randint(0, xspace)),\n        ypos=thisGRP.ypos() + (yspace*4)\n    )\n\n    veg_crypto_GRP.setName('VegetationLayerEncryptomatte')\n\n    veg_crypto_GRP.addKnob(nuke.Tab_Knob('tab_crypto', 'Cryptomatte Layer'))\n    # Description\n    veg_crypto_GRP.addKnob(nuke.Text_Knob('node_description', '',\n                                          'This Node combines all vegetation layer masks into one vegetation cryptomatte layer. \\n'\n                                          'Simply insert this node after your scatter setup scanline render node. \\n'\n                                          'If you add or remove any layers to your VegetationLoader, recreate this node from there.'))\n\n    veg_crypto_GRP.addKnob(nuke.Text_Knob('spacer1', '', '<br>'))\n\n    veg_crypto_GRP.addKnob(nuke.String_Knob('crypto_channel_name', 'Cryptomatte Channel Name'))\n    veg_crypto_GRP\['crypto_channel_name'].setValue('VegetationCrypto')\n    veg_crypto_GRP\['crypto_channel_name'].setEnabled(False)\n\n    veg_crypto_GRP.addKnob(nuke.Text_Knob('spacer2', '', '<br>'))\n\n    veg_crypto_GRP.addKnob(nuke.Text_Knob('crypto_options', 'Options', ''))\n\n    # Active Input Checkbox and Indicator\n    veg_crypto_GRP.addKnob(nuke.Boolean_Knob('remove_vegetation_layers', 'Remove Vegetation Layers'))\n    veg_crypto_GRP\['remove_vegetation_layers'].setValue(1)\n\n\n\n\n    # add version that was used to create this note for debugging purposes\n    veg_crypto_GRP.addKnob(nuke.Tab_Knob('tab_info', 'Info'))\n    veg_crypto_GRP.addKnob(nuke.Text_Knob('version_info',_thisG\['version_info'].label(), _thisG\['version_info'].value()))\n    # add documentation link\n    veg_crypto_GRP.addKnob(nuke.Text_Knob('documentation_info', '<font color=cyan>documentation :</font>',\n                                          \"<a href ='http://docsie/index.php/MScatterGeo'><font color='orange'>Docsie</font ></a>\"))\n\n\n\n    with veg_crypto_GRP:\n        in_node = nuke.nodes.Input()\n        out_node = nuke.nodes.Output()\n\n        layer_set_up = False\n        connect_node = in_node\n\n        for channel in mask_channel_list:\n            shuffle_node = nuke.nodes.Shuffle2()\n            encrypto_node = nuke.nodes.Encryptomatte()\n\n            shuffle_node.knob('in1').setValue(channel)\n            shuffle_node.setInput(0, in_node)\n\n            encrypto_node.knob('matteName').setValue(channel)\n            encrypto_node.knob('cryptoLayer').setValue(veg_crypto_GRP\['crypto_channel_name'].getValue())\n            if not layer_set_up:\n                encrypto_node.knob('setupLayers').setValue(1)\n                layer_set_up = True\n            encrypto_node.setInput(0, connect_node)\n            encrypto_node.setInput(1, shuffle_node)\n\n            connect_node = encrypto_node\n\n\n        for channel in mask_channel_list:\n            remove_node = nuke.nodes.Remove()\n            remove_node.knob('channels').setValue(channel)\n            remove_node.knob('disable').setExpression('!parent.remove_vegetation_layers')\n\n            remove_node.setInput(0, connect_node)\n            connect_node = remove_node\n\n        out_node.setInput(0, connect_node)\n\nvegetationLoader = nuke.thisNode()\nlayer_list = vegetationLoader.knob('input_layer_list').values()\nwith getLevel():\n    new_veg_loader = create_crypto_from_mask_channels(layer_list, vegetationLoader)\n" +STARTLINE}
  addUserKnob {43 filterNonReverse +DISABLED}
  filterNonReverse Camera,Camera2,Light,Light2,DirectLight,Environment,Axis,Axis2
  addUserKnob {43 filter3DNodes +DISABLED}
  filter3DNodes Axis,Axis2,Card,Card2,Cube,Cylinder,Sphere,ReadGeo,ReadGeo2,Light,Light2,DirectLight,Spotlight,Environment,TransformGeo,EditGeo,Camera,Camera2
  addUserKnob {43 filterPrimitives +DISABLED}
  filterPrimitives Card,Card2,Cube,Cylinder,Sphere,ReadGeo,ReadGeo2
 }
end_group
Dot {
 inputs 0
 name Dot80
 selected true
 xpos -34466
 ypos 12194
}
Dot {
 name Dot81
 selected true
 xpos -34183
 ypos 12194
}
set Ne18789c0 [stack 0]
Dot {
 name Dot97
 selected true
 xpos -34183
 ypos 12512
}
push $Ne18789c0
push $cut_paste_input
Dot {
 name Dot98
 selected true
 xpos -34050
 ypos 11626
}
ReadGeo2 {
 file /data/share/Jeevan/truck_side_v001.fbx
 read_on_each_frame true
 range_first 1000
 range_last 1039
 name ReadGeo1
 selected true
 xpos -34083
 ypos 11914
}
Normals {
 action build
 name Normals2
 selected true
 xpos -34083
 ypos 11981
}
ieStickyProject {
 inputs 2
 name ieStickyProject2
 selected true
 xpos -34083
 ypos 12196
}
push 0
ScanlineRender {
 inputs 3
 conservative_shader_sampling false
 overscan {0 1}
 shutteroffset centred
 motion_vectors_type distance
 name ScanlineRender1
 selected true
 xpos -34083
 ypos 12514
}
